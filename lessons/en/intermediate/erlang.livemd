# Erlang Interoperability

## Standard Library

Erlang's extensive standard library can be accessed from any Elixir code in our application.
Erlang modules are represented by lowercase atoms such as `:os` and `:timer`.

Let's use `:timer.tc` to time execution of a given function:


```elixir
 Example.timed(fn (n) -> (n * n) * n end, [100])
```

For a complete list of the modules available, see the [Erlang Reference Manual](http://erlang.org/doc/apps/stdlib/).

## Erlang Packages

In a prior lesson we covered Mix and managing our dependencies.
Including Erlang libraries works the same way.
In the event the Erlang library has not been pushed to [Hex](https://hex.pm) you can refer to the git repository instead:


```elixir
def deps do
  [{:png, github: "yuce/png"}]
end
```

Now we can access our Erlang library:


```elixir
png =
  :png.create(%{:size => {30, 30}, :mode => {:indexed, 8}, :file => file, :palette => palette})
```

## Notable Differences

Now that we know how to use Erlang we should cover some of the gotchas that come with Erlang interoperability.

### Atoms

Erlang atoms look much like their Elixir counterparts without the colon (`:`).
They are represented by lowercase strings and underscores:

Elixir:


```elixir
:example
```

Erlang:

```erlang
example.
```

### Strings

In Elixir when we talk about strings we mean UTF-8 encoded binaries.
In Erlang, strings still use double quotes but refer to char lists:

Elixir:


```elixir
 is_list('Example')
```

```elixir
 is_list("Example")
```

```elixir
 is_binary("Example")
```

```elixir
 <<"Example">> === "Example"
```

Erlang:

```erlang
1> is_list('Example').
false
2> is_list("Example").
true
3> is_binary("Example").
false
4> is_binary(<<"Example">>).
true
```

It's important to note that many older Erlang libraries may not support binaries so we need to convert Elixir strings to char lists.
Thankfully this is easy to accomplish with the `to_charlist/1` function:


```elixir
 :string.words("Hello World")
```

```elixir
 "Hello World" |> to_charlist() |> :string.words
```

### Variables

In Erlang, variables begin with an uppercase letter and re-binding is not allowed.

Elixir:


```elixir
 x = 10
```

```elixir
 x = 20
```

```elixir
 x1 = x + 10
```

Erlang:

```erlang
1> X = 10.
10

2> X = 20.
** exception error: no match of right hand side value 20

3> X1 = X + 10.
20
```

That's it! Leveraging Erlang from within our Elixir applications is easy and effectively doubles the number of libraries available to us.
