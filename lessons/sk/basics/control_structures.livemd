# Riadiace štruktúry

## if a unless

Na funkciu `if/2` ste už pravdepodobne narazili a ak ste pracovali s Ruby, poznáte aj `unless/2`. V Elixire fungujú úplne rovnako, no sú implementované ako makrá, nie sú to skutočné jazykové konštrukty. Ich implementáciu si môžete pozrieť v dokumentácii [modulu Kernel](https://hexdocs.pm/elixir/Kernel.html).

Len pre pripomenutie: je dôležité si uvedomiť, že jediné hodnoty, ktoré Elixir vyhodnotí ako `false` (v angličtine sa používa výraz *falsey*), sú hodnoty `nil` a `false`.


```elixir
 if String.valid?("Hello") do
```

```elixir
 if "a string value" do
```

Použitie `unless/2` je analogické k `if/2` - pracuje opačne, t.j. ako *if not*:


```elixir
 unless is_integer("hello") do
```

## case

Ak potrebujeme hodnotu porovnať s viacerými možnosťami (vzormi), môžeme použiť `case/2`:


```elixir
 case {:ok, "Hello World"} do
```

Špeciálna premenná `_` má v `case/2` význam *žolíka*, teda matchne čokoľvek. Používa sa podobne, ako *else* alebo *default* vetva v iných jazykoch. Bez nej nám `case/2` vyhodí chybu, ak sa mu nepodarí matchnúť hodnotu do niektorej zo svojich vetiev:


```elixir
 case :even do
```

```elixir
 case :even do
```

Keďže výraz `case/2` je založený na pattern matchingu, platia preň všetky jeho pravidlá a obmedzenia. Ak chceme matchovať oproti existujúcim premenným (t.j. nepriraďovať do nich), musíme použiť operátor *pin* (`^/1`):


```elixir
 pie = 3.14
```

```elixir
 case "cherry pie" do
```

Výborná vec, ktorú nám `case/2` umožňuje použiť, sú tzv. *guard clauses* (hraničné podmienky):

_Nasledujúci príklad pochádza priamo z oficiálnej príručky Elixiru [Getting Started](http://elixir-lang.org/getting-started/case-cond-and-if.html#case)._


```elixir
 case {1, 2, 3} do
```

Pozrite si príslušnú kapitolu v oficiálnej dokumentácii [Expressions allowed in guard clauses](https://hexdocs.pm/elixir/guards.html#list-of-allowed-expressions).


## cond

Keď potrebujeme vetviť na základe podmienok, nie hodnôt, použijeme `cond/1` - funguje to podobne ako séria `else if` alebo `elsif` v iných jazykoch:

_Nasledujúci príklad pochádza priamo z oficiálnej príručky Elixiru [Getting Started](http://elixir-lang.org/getting-started/case-cond-and-if.html#cond)._


```elixir
 cond do
```

Podobne ako `case/2` aj `cond/1` vyhodí chybu, ak nenájde použiteľnú vetvu. V tom prípade musíme vytvoriť vetvu s podmienkou `true`, ktorá takéto prípady odchytí:


```elixir
 cond do
```

## with

Špeciálna riadiaca štruktúra `with/1` je užitočná, keď potrebujeme použiť vnorené `case/2` výrazy alebo v situácii keď ich nemôžeme spojiť pomocou operátora pipe. Výraz `with/1` je zložený z kľúčových slov, generátorov a výrazu.

O generátoroch si povieme viac v [lekcii o comprehensions](/sk/lessons/basics/comprehensions), ale zatiaľ stačí keď vieme, že používajú [pattern matching](/sk/lessons/basics/pattern_matching) na porovnanie pravej strany operátora `<-` s ľavou stranou.

Začneme s jednoduchým príkladom ako použiť `with/1`:


```elixir
 user = %{first: "Sean", last: "Callan"}
```

```elixir
 with {:ok, first} <- Map.fetch(user, :first),
```

V prípade, že pattern matching výrazu je neúspešný, nehodiaca sa hodnota bude vrátená:


```elixir
 user = %{first: "doomspork"}
```

```elixir
 with {:ok, first} <- Map.fetch(user, :first),
```

Teraz máme väčší príklad bez `with/1` a potom sa pozrieme ako ho môžeme zrefaktorovať:


```elixir
case Repo.insert(changeset) do
  {:ok, user} ->
    case Guardian.encode_and_sign(user, :token, claims) do
      {:ok, token, full_claims} ->
        important_stuff(token, full_claims)

      error ->
        error
    end

  error ->
    error
end
```

Keď zavedieme `with/1`, dostaneme kód, ktorý je ľahšie pochopiteľný, čitateľný a má menej riadkov:


```elixir
with {:ok, user} <- Repo.insert(changeset),
     {:ok, token, full_claims} <- Guardian.encode_and_sign(user, :token, claims) do
  important_stuff(token, full_claims)
end
```

Od verzie Elixiru 1.3, `with/1` výrazy podporujú `else`:


```elixir
import Integer

m = %{a: 1, c: 3}

a =
  with {:ok, number} <- Map.fetch(m, :a),
       true <- is_even(number) do
    IO.puts("#{number} divided by 2 is #{div(number, 2)}")
    :even
  else
    :error ->
      IO.puts("We don't have this item in map")
      :error

    _ ->
      IO.puts("It is odd")
      :odd
  end
```

To nám pomáha spracovať chyby tým, že poskytuje pattern matching podobný `case`. Vzor vo vetve `else` je prvá nehodiaca sa hodnota výrazu.
