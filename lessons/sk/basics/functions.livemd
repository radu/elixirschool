# Funkcie

## Anonymné funkcie

Ako naznačuje už ich názov, tieto funkcie nemajú meno. V kapitole o `Enum` sme videli, že sa často odovzdávajú ako argumenty iným funkciám. Na definovanie anonymnej funkcie slúžia v Elixire kľúčové slová `fn` a `end`. Medzi nimi môžeme definovať ľubovoľné množstvo kombinácii argumentov a tiel funkcií - oddelených operátorom `->`.

Pozrime sa na jednoduchý príklad:


```elixir
 sum = fn (a, b) -> a + b end
```

```elixir
 sum.(2, 3)
```

Všimnite si, že anonymnú funkciu je nutné volať cez `.`.

### Skratka &

Používanie anonymných funkcií je v Elixire natoľko bežné, že na ich definovanie existuje skrátený zápis pomocou `&`:


```elixir
 sum = &(&1 + &2)
```

```elixir
 sum.(2, 3)
```

Ako ste asi uhádli, v skrátenom zápise máme k dodaným argumentom prístup cez `&1`, `&2`, `&3` atď.

## Pattern matching

V Elixire nie je pattern matching obmedzený len na premenné - môže byť využitý aj v hlavičkách funkcií. Jeho aplikáciou na vstupné argumenty sa určí, ktoré telo funkcie sa použije (to, ktoré prislúcha k prvej vyhovujúcej hlavičke).

Elixir používa pattern matching na nájdenie zhodnej funkcie a zvolí prvú vyhovujúcu funkciu:


```elixir
 handle_result = fn
```

```elixir
 some_result = 1
```

```elixir
 handle_result.({:ok, some_result})
```

```elixir
 handle_result.({:error})
```

V príklade sme si definovali funkciu s dvoma telami. Pri jej prvom volaní sa použilo prvé telo, keďže sme jej ako argumenty poslali tuple v tvare `{:ok, result}`. Pri druhom volaní sa použilo druhé telo, keďže ako argument od nás dostala tuple v tvare `{:error}`.

## Pomenované funkcie

Druhým spôsobom, ako definovať funkciu, je priradiť jej už pri definícii meno, ktorým na ňu neskôr budeme odkazovať. Pri tomto spôsobe použijeme kľúčové slovo `def` vo vnútri nejakého modulu (o moduloch si povieme viac v ďalšej lekcii).

Funkcie definované v module sú k dispozícii pre použitie v iných moduloch. V Elixire sú moduly jedným z najdôležitejších stavebných blokov.


```elixir
 Greeter.hello("Sean")
```

Ak má telo funkcie len jediný riadok, môžme použiť kratší zápis definície pomocou `do:`:


```elixir
defmodule Greeter do
  def hello(name), do: "Hello, " <> name
end
```

Vyzbrojení pattern matchingom, vyskúšajme si rekurziu pomocou pomenovaných funkcií:


```elixir
 Length.of []
```

```elixir
 Length.of [1, 2, 3]
```

### Pomenovanie funkcií a počet argumentov

Už sme si spomenuli skôr, že funkcie sú pomenované kombináciou ich mena a počtom argumentov (`arity`). To znamená, že môžeme spraviť aj niečo ako:


```elixir
 Greeter2.hello()
```

```elixir
 Greeter2.hello("Fred")
```

```elixir
 Greeter2.hello("Fred", "Jane")
```

V komentároch máme mená funkcii vyššie. Prvá implementácia nemá žiadne argumenty, tak je označená ako `hello/0`. Druhá funkcia má jeden argument, takže jej názov je `hello/1` atď.
Narozdiel od iných jazykov, kde by takéto niečo bolo považované za preťaženie funkcie, no v Elixire sú považované za úplne od seba _rôzne_ funkcie. (Pattern matching, spomenutý vyššie je použitý iba vtedy, keď poskytneme viac definícií pre funkciu s _rovnakým_ počtom argumentov.)

### Privátne funkcie

Ak nechceme, aby naša funkcia mohla byť volaná z iných modulov, môžeme ju zadefinovať ako privátnu - takto ju bude možné volať len z vnútra jej vlastného modulu. Na definovanie privátnych funkcií slúži kľúčové slovo `defp`:


```elixir
 Greeter.hello("Sean")
```

```elixir
 Greeter.phrase
```

### Hraničné podmienky

Hraničných podmienok (*guards*) sme sa krátko dotkli v kapitole o [riadiacich štruktúrach](/sk/lessons/basics/control_structures). Teraz sa pozrieme na ich využitie pri definovaní pomenovaných funkcií.
Keď Elixir vybral funkciu, akékoľvek existujúce hraničné podmienky budú otestované.

V nasledujúcom príklade máme dve funkcie s tou istou hlavičkou, no rôznymi hraničnými podmienkami. Testujeme typ parametra:


```elixir
 Greeter.hello ["Sean", "Steve"]
```

### Východiskové hodnoty argumentov

Ak chceme, aby mal niektorý z argumentov funkcie východiskovú hodnotu, použijeme syntax `argument \\ hodnota`:


```elixir
 Greeter.hello("Sean", "en")
```

```elixir
 Greeter.hello("Sean")
```

```elixir
 Greeter.hello("Sean", "sk")
```

Problém môže nastať, ak nevhodne skombinujeme hraničné podmienky s východiskovými argumentami:


```elixir
defmodule Greeter do
  def hello(names, language_code \\ "en") when is_list(names) do
    names = Enum.join(names, ", ")
    
    hello(names, language_code)
  end

  def hello(name, language_code \\ "en") when is_binary(name) do
    phrase(language_code) <> name
  end

  defp phrase("en"), do: "Hello, "
  defp phrase("es"), do: "Hola, "
end

** (CompileError) iex:31: definitions with multiple clauses and default values require a header. Instead of:

    def foo(:first_clause, b \\ :default) do ... end
    def foo(:second_clause, b) do ... end

one should write:

    def foo(a, b \\ :default)
    def foo(:first_clause, b) do ... end
    def foo(:second_clause, b) do ... end

def hello/2 has multiple clauses and defines defaults in one or more clauses
    iex:31: (module)
```

Elixir nerád vidí východiskové argumenty vo viacerých zhodných hlavičkách funkcie, pretože to môže byť mätúce. Riešenie spočíva v pridaní hlavičky s východiskovými argumentami, pričom z pôvodných hlavičiek východiskové argumenty odstránime:


```elixir
 Greeter.hello ["Sean", "Steve"]
```

```elixir
 Greeter.hello ["Sean", "Steve"], "es"
```
