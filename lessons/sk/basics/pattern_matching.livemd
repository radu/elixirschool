# Pattern Matching

## Match operator

Pripravení na prekvapenie? V Elixire je operátor `=` v skutočnosti match operátorom, porovnateľný so znamienkom rovná sa v algebre. Jeho napísaním sa zmení celý výraz na rovnicu a donúti Elixir nachádzať a vyberať časti vľavo z hodnôt, ktoré sú na pravej strane. Ak nastane zhoda a match je úspešný, vráti hodnotu výrazu. Inak vyhodí chybu. Pozrime sa na to:


```elixir
 x = 1
```

Skúsme niečo zložitejšie:


```elixir
 1 = x
```

```elixir
 2 = x
```

Skúsme to s nejakou kolekciou, ktorú poznáme:


```elixir
 list = [1, 2, 3]
```

```elixir
 [1, 2, 3] = list
```

```elixir
 [] = list
```

```elixir
 [1 | tail] = list
```

```elixir
 tail
```

```elixir
 [2 | _] = list
```

```elixir
 {:ok, value} = {:ok, "Successful!"}
```

```elixir
 value
```

```elixir
 {:ok, value} = {:error}
```

## Pin operator

Práve sme sa naučili, že *match* operátor vykoná priradenie, ak sa na jeho ľavej strane nachádza premenná. Niekedy je však toto správanie (tzv. *variable rebinding*) nežiadúce a pre tieto prípady existuje v Elixire operátor pin: `^`.

Keď pri pattern matchingu dáme pred premennú pin (`^`), tak tým Elixiru povieme, aby jej hodnotu len použil pri porovnávaní, no nemenil ju:


```elixir
 x = 1
```

```elixir
 ^x = 2
```

```elixir
 {x, ^x} = {2, 1}
```

```elixir
 x
```

Od verzie 1.2 podporuje Elixir používanie pinov v mapách a definíciách funkcií:


```elixir
 key = "hello"
```

```elixir
 %{^key => value} = %{"hello" => "world"}
```

```elixir
 value
```

```elixir
 %{^key => value} = %{:hello => "world"}
```

Príklad použitia pinu v definícii funkcie:


```elixir
 greeting = "Hello"
```

```elixir
 greet = fn
```

```elixir
 greet.("Hello", "Sean")
```

```elixir
 greet.("Mornin'", "Sean")
```

Všimnite si v príklade s `"Mornin'"`, že premenná `greeting` dostane hodnotu `"Mornin'"` iba vo vnútri funkcie. Mimo funkcie má premenná `greeting` stále hodnotu `"Hello"`.
