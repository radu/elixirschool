# Колекції

## Списки
Списки — це звичайні колекції значень. 
Вони можуть включати різні типи та неунікальні значення.


```elixir
 [3.14, :pie, "Apple"]
```

Списки в Elixir є однобічно зв'язними.
Це означає, що отримання довжини списку - операція, яка буде виконана за лінійний час (`O(n)`).
Із цієї причини додавати елементи в початок списку набагато швидше, ніж у його кінець.


```elixir
 list = [3.14, :pie, "Apple"]
```

```elixir
 ["π" | list]
```

```elixir
 list ++ ["Cherry"]
```

### Об'єднання списків

Для об'єднання списків використовується оператор `++/2`:


```elixir
 [1, 2] ++ [3, 4, 1]
```

Невелика замітка щодо формату імен (`++/2`), який використовувався вище: в
Elixir (та й в Erlang, на основі якого створений Elixir) імена функцій та
операторів складаються з двох частин: безпосередньо імені (в цьому випадку `++`)
та _арності_. Арність — одне з ключових понять Elixir та Erlang. Це
кількість аргументів, які приймає функція (у цьому випадку два). Арність та ім'я
з'єднуються за допомогою слешa. Пізніше ми розберемо це детальніше.

### Віднімання списків

Оператор `--/2` дає можливість віднімати списки. Не буде помилкою віднімання неіснуючого елемента:


```elixir
 ["foo", :bar, 42] -- [42, "bar"]
```

Зверніть увагу на повторні значення. 
З лівого списку видаляється тільки перше входження кожного елемента правого списку:


```elixir
 [1,2,2,3,2,3] -- [1,2,3,2]
```

**Зауваження:** Для порівняння елементів використовується [строге порівняння](/uk/lessons/basics/basics#Порівняння). 
Наприклад:

```elixir
 [2] -- [2.0]
```

```elixir
 [2.0] -- [2.0]
```

### Голова / Хвіст

Під час використання списків звичайною є робота з "головою" та "хвостом" списку.
"Головою" є перший елемент, а "хвостом" — усі інші елементи.
Для роботи з ними Elixir надає два оператори — `hd` та `tl`:


```elixir
 hd [3.14, :pie, "Apple"]
```

```elixir
 tl [3.14, :pie, "Apple"]
```

Того ж результату можливо досягти, використовуючи [зіставлення зі зразком](/uk/lessons/basics/pattern_matching) 
aбо оператор cons — `|`. Ми будемо часто його зустрічати в наступних уроках.


```elixir
 [head | tail] = [3.14, :pie, "Apple"]
```

```elixir
 head
```

```elixir
 tail
```

## Кортежі

Кортежі схожі на списки, але зберігаються в пам'яті послідовно.
Це робить отримання їх довжини швидким, але але редагування "дорогим";
новостворений кортеж повинен бути повністю cкопійованим у нову область пам'яті.
Кортежі створюються за допомогою фігурних дужок:


```elixir
 {3.14, :pie, "Apple"}
```

Часто вони використовуються як механізм для отримання додаткової інформації з функцій. 
Користь цього стане більш очевидною пізніше, коли ми будемо заглиблюватися в 
[зіставлення зі зразком](/uk/lessons/basics/pattern_matching):


```elixir
 File.read("path/to/existing/file")
```

```elixir
 File.read("path/to/unknown/file")
```

## Ключові списки

Ключові списки та асоціативні масиви є асоціативнними колекціми в Elixir.
В Elixir ключові списки — це спеціальні списки з двоелементних кортежів, 
першим елементом яких є атом. По швидкості вони ідентичні спискам.


```elixir
 [foo: "bar", hello: "world"]
```

```elixir
 [{:foo, "bar"}, {:hello, "world"}]
```

Три характеристики цієї структури даних показують її важливість:

+ Ключі є атомами.
+ Ключі є впорядкованими.
+ Ключі не повинні бути унікальними.

Тому вона часто використовується для передачі параметрів у функції.

## Асоціативні масиви

В Elixir асоціативний масив — це сховище типу ключ-значення з можливістю швидкого отримання 
інформації по ключу. На відміну від ключових списків, вони підтримують будь-який тип ключів і не є 
впорядкованими. Асоціативний масив оголошується за допомогою синтаксису `%{}`:


```elixir
 map = %{:foo => "bar", "hello" => :world}
```

```elixir
 map[:foo]
```

```elixir
 map["hello"]
```

З версії Elixir 1.2 змінні підтримуються у якості ключів:


```elixir
 key = "hello"
```

```elixir
 %{key => "world"}
```

Якщо в цю структуру даних додається дублікат, він перепише старе значення:


```elixir
 %{:foo => "bar", :foo => "hello world"}
```

Як видно з результату команди вище, існує спеціальний короткий синтаксис для асоціативних масивів, 
ключами яких є тільки атоми:


```elixir
 %{foo: "bar", hello: "world"}
```

```elixir
 %{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}
```

Також існує спеціальний синтаксис для отримання значень ключів-атомів:


```elixir
 map = %{foo: "bar", hello: "world"}
```

```elixir
 map.hello
```

Ще одна цікава особливість асоціативних масивів — це особливий синтаксис для оновлення 
(зауваження: це створює новий асоціативний масив):


```elixir
 map = %{foo: "bar", hello: "world"}
```

```elixir
 %{map | foo: "baz"}
```

**Зауваження**: цей синтаксис працює лише для оновлення ключа, який уже існує в асоціативному 
масиві! Якщо ключ не існує, ви отримаєте `KeyError`.

Для того, щоб створити новий ключ, використовуйте [`Map.put/3`](https://hexdocs.pm/elixir/Map.html#put/3)


```elixir
 map = %{hello: "world"}
```

```elixir
 %{map | foo: "baz"}
```

```elixir
 Map.put(map, :foo, "baz")
```
