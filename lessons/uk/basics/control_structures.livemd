# Керуючі конструкції

## if та unless

Скоріш за все, ви вже зустрічали оператор `if/2`, а якщо програмували на Ruby, то зустрічали і `unless/2`. В Elixir вони функціонують так само, але визначені як макрос, а не конструкція мови. Код реалізації можливо побачити в модулі [Kernel](https://hexdocs.pm/elixir/Kernel.html).

Варто зазначити, що в Elixir єдиним хибними значеннями є `nil` та `false`.


```elixir
 if String.valid?("Hello") do
```

```elixir
 if "a string value" do
```

`unless/2` схожий на `if/2`, але працює навпаки:


```elixir
 unless is_integer("hello") do
```

## case

Якщо потрібно зіставити з декількома зразками, використовується оператор `case/2`:


```elixir
 case {:ok, "Hello World"} do
```

Змінна `_` є важливою частиною конструкції `case/2`. Без неї, у випадку відсутності знайденого зіставлення, станеться помилка:


```elixir
 case :even do
```

```elixir
 case :even do
```

Змінну `_` можливо розглядати як `else`, котрий буде зіставлений з чим завгодно.
Так, як `case/2` базується на зіставлені зі зразком, то всі ті ж обмеження і особливості продовжують діяти. Якщо потрібно провести зіставлення зі значенням змінної замість її присвоєння, використовується вже знайомий оператор `^/1`:


```elixir
 pie = 3.14
```

```elixir
 case "cherry pie" do
```

Другою цікавою можливістю `case/2` є підтримка обмежувальних виразів:

_Цей приклад взятий з офіційної документації [Getting Started](http://elixir-lang.org/getting-started/case-cond-and-if.html#case)._


```elixir
 case {1, 2, 3} do
```

Також рекомендуємо почитати офіційну документацію про [вирази, доступні в обмежувальних виразах](https://hexdocs.pm/elixir/guards.html#list-of-allowed-expressions).

## cond

Коли потрібно перевіряти умови, а не значення, можна скористатися `cond/1`. Це схоже на `else if` чи `elsif` в інших мовах:

_Цей приклад взятий з офіційної документації [Getting Started](http://elixir-lang.org/getting-started/case-cond-and-if.html#cond)._


```elixir
 cond do
```

Так само, як і `case/2`, `cond/1` викличе помилку, якщо не пройде жоден з виразів. Для вирішення цієї проблеми можна визначити умову в `true`:


```elixir
 cond do
```

## with

Спеціальна форма `with/1` може знадобитися в ситуаціях, коли важко використовувати оператор потоку, або коли потрібен вкладений виклик `case/2`. `with/1` складається з ключових слів, генераторів та виразу в кінці.

Ми ще поговоримо про генератори в [уроці про спискові включення](/uk/lessons/basics/comprehensions), але зараз нам достатньо знати лише те, що вони використовують [зіставлення зі зразком](/uk/lessons/basics/pattern_matching) для порівняння правої частини `<-` з лівою.

Почнемо з простого прикладу з `with/1`:


```elixir
 user = %{first: "Sean", last: "Callan"}
```

```elixir
 with {:ok, first} <- Map.fetch(user, :first),
```

У випадку, якщо для виразу не знайдеться збіг, повернеться значення, яке не збіглося:


```elixir
 user = %{first: "doomspork"}
```

```elixir
 with {:ok, first} <- Map.fetch(user, :first),
```

Давайте глянемо на приклад побільше без використання `with/1`, а потім подивимось, як його можна покращити:


```elixir
case Repo.insert(changeset) do
  {:ok, user} ->
    case Guardian.encode_and_sign(user, :token, claims) do
      {:ok, token, full_claims} ->
        important_stuff(token, full_claims)

      error ->
        error
    end

  error ->
    error
end
```

А тепер, завдяки `with/1`, ми отримаємо короткий та простий для розуміння код:


```elixir
with {:ok, user} <- Repo.insert(changeset),
     {:ok, token, full_claims} <- Guardian.encode_and_sign(user, :token, claims) do
  important_stuff(token, full_claims)
end
```

Починаючи з версії Elixir 1.3, конструкція `with/1` також почала підтримувати `else`:


```elixir
import Integer

m = %{a: 1, c: 3}

a =
  with {:ok, number} <- Map.fetch(m, :a),
       true <- is_even(number) do
    IO.puts("#{number} divided by 2 is #{div(number, 2)}")
    :even
  else
    :error ->
      IO.puts("We don't have this item in map")
      :error

    _ ->
      IO.puts("It is odd")
      :odd
  end
```

Це допомагає структурувати код обробки помилок за допомогою зіставлення зі зразком в загальному блоці-обробнику. Значення, котре туди передаєтеся — перший же вираз, який не зіставився в основному тілі `with`.
