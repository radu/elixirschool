# Bases

## Installation

### Installer Elixir

Les instructions d'installation pour chaque système d'exploitation se trouvent sur elixir-lang.org dans le [guide d'installation.](http://elixir-lang.org/install.html).

Une fois qu'Elixir est installé, nous pouvons facilement trouver la version installée.

    % elixir -v
    Erlang/OTP {{ site.erlang.OTP }} [erts-{{ site.erlang.erts }}] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

    Elixir {{ site.elixir.version }}

### Essayer le Mode Interactif

Elixir vient avec `iex`, un shell interactif qui nous permet d'évaluer des expressions Elixir au fur et à mesure.

Pour commencer, lançons `iex`:

    Erlang/OTP {{ site.erlang.OTP }} [erts-{{ site.erlang.erts }}] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

    Interactive Elixir ({{ site.elixir.version }}) - press Ctrl+C to exit (type h() ENTER for help)
    iex>

Note: Sous Windows PowerShell, il faut taper `iex.bat`.

Maintenant, essayons `iex` en tapant quelques expressions simples:


```elixir
 2+3
```

```elixir
 2+3 == 5
```

```elixir
 String.length("The quick brown fox jumps over the lazy dog")
```

Ce n'est pas grave si vous ne comprenez pas chaque expression maintenant, autant que vous comprenez le principe.

## Types de base

### Entiers (Integers)


```elixir
 255
```

Il y a également le support des notations binaires, octales et hexadécimales :


```elixir
 0b0110
```

```elixir
 0o644
```

```elixir
 0x1F
```

### Nombres à virgule flottante (Floats)

En Elixir, les nombres à virgule flottantes requièrent une décimale après au moins une chiffre; elles ont une précision de l'ordre d'un `double` de 64 bits et offrent le support de la notation `e` pour les exponentielles.


```elixir
 3.14
```

```elixir
 .14
```

```elixir
 1.0e-10
```

### Booléens (Booleans)

Elixir supporte `true` et `false` comme valeurs booléennes; tout est considéré comme vrai (truthy) à part `false` et `nil` :


```elixir
 true
```

```elixir
 false
```

### Atomes (Atoms)

Un atome est une constante qui a pour valeur son nom. Si vous êtes familiers avec Ruby, ils sont synonymes du type `Symbol`


```elixir
 :foo
```

```elixir
 :foo == :bar
```

NOTE : Les booléens `true` et `false` sont aussi respectivement les atomes `:true` et `:false`.


```elixir
 is_atom(true)
```

```elixir
 is_boolean(:true)
```

```elixir
 :true === true
```

Les noms de modules en Elixir sont aussi des atomes. `MyApp.MyModule` est un atome valide, même si aucun module de ce nom n'a pas encore été déclaré.


```elixir
 is_atom(MyApp.MyModule)
```

Les atomes sont aussi utilisés pour référencer les modules de bibliothèques Erlang, y compris celles inclues de base.


```elixir
 :crypto.strong_rand_bytes 3
```

### Chaînes de caractères (Strings)

Les chaînes de caractères en Elixir sont encodées en UTF-8 et entourées de guillemets droits doubles :


```elixir
 "Hello"
```

```elixir
 "dziękuję"
```

Les chaînes de caractères supportent les retours à la ligne et les séquences d'échappement :


```elixir
 "foo
```

```elixir
 "foo\nbar"
```

Elixir comprend aussi des types plus complexes. Nous verrons plus à ce sujet en parlant des [collections](/fr/lessons/basics/collections) et des [fonctions](/fr/lessons/basics/functions).

## Opérations de base

### Arithmétique

Elixir supporte les opérateurs `+`, `-`, `*` et `/` comme prévu. Il est important de se souvenir que `/` retournera toujours un nombre à virgule flottante :


```elixir
 2 + 2
```

```elixir
 2 - 1
```

```elixir
 2 * 5
```

```elixir
 10 / 5
```

Si vous avez besoin du reste d'une division ou d'une division entière (le modulo), Elixir comprend deux fonctions bien utiles pour les obtenir :


```elixir
 div(10, 5)
```

```elixir
 rem(10, 3)
```

### Booléens

Elixir fournit les opérateurs booléens `||`, `&&` et `!`. Ils supportent n'importe quel type:


```elixir
 -20 || true
```

```elixir
 false || 42
```

```elixir
 42 && true
```

```elixir
 42 && nil
```

```elixir
 !42
```

```elixir
 !false
```

Il y a trois opérateurs additionnels, dont le premier argument _doit_ être un booléen (`true` ou `false`) :


```elixir
 true and 42
```

```elixir
 false or true
```

```elixir
 not false
```

```elixir
 42 and true
```

```elixir
 not 42
```

Note: Les opérateurs `and` et `or` d'Elixir mappent en fait à `andalso` et `orelse` en Erlang.

### Comparaison

Elixir a tous les opérateurs de comparaison habituels: `==`, `!=`, `===`, `!==`, `<=`, `>=`, `<` et `>`.


```elixir
 1 > 2
```

```elixir
 1 != 2
```

```elixir
 2 == 2
```

```elixir
 2 <= 3
```

Pour une comparaison stricte d'entiers et de nombres à virgule flottante, utilisez `===` :


```elixir
 2 == 2.0
```

```elixir
 2 === 2.0
```

Une fonctionnalité importante d'Elixir est que deux types différents peuvent être comparés, ce qui est particulièrement utile quand on effectue un tri. Nous n'avons pas besoin de mémoriser l'ordre de tri mais il est important d'en être conscient :


```elixir
number < atom < reference < function < port < pid < tuple < map < list < bitstring
```

Cela permet de réaliser des comparaisons intéressantes, que vous ne trouveriez pas dans d'autres langages :


```elixir
 :hello > 999
```

```elixir
 {:hello, :world} > [1, 2, 3]
```

### Interpolation des chaînes de caractères

Si vous avez déjà utilisé Ruby, l'interpolation en Elixir vous semblera familière :


```elixir
 name = "Sean"
```

```elixir
 "Hello #{name}"
```

### Concaténation de chaînes de caractères

La concaténation de chaînes utilise l'opérateur `<>` :


```elixir
 name = "Sean"
```

```elixir
 "Hello " <> name
```
