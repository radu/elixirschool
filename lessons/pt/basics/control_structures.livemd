# Estruturas de Controle

## if e unless

Existem chances de que você já tenha encontrado `if/2` antes, e caso você tenha utilizado Ruby você é familiarizado com `unless/2`. Em Elixir eles trabalham praticamente da mesma forma porém são definidos como macros, não construtores da linguagem; Você pode encontrar a implementação deles em [Kernel module](https://hexdocs.pm/elixir/Kernel.html).

Pode-se notar que em Elixir, os únicos valores falsos são `nil` e o booleano `false`.


```elixir
 if String.valid?("Hello") do
```

```elixir
 if "a string value" do
```
Usar `unless/2` é bem parecido com o uso do `if/2` porém trabalhando de forma negativa:

```elixir
 unless is_integer("hello") do
```

## case

Caso seja necessário combinar múltiplos padrões nós poderemos utilizar `case/2`:


```elixir
 case {:ok, "Hello World"} do
```
A variável `_` é uma importante inclusão na declaração do `case/2`. Sem isso a falha em procura de combinação iria causar um erro:


```elixir
 case :even do
```

```elixir
 case :even do
```

Considere `_` como o `else` que irá igualar com "todo o resto".
Já que `case/2` depende de combinação de padrões, todas as mesmas regras e restrições são aplicadas. Se você pretende procurar padrões em variáveis que já existem, você irá precisar utilizar o operador pin `^/1`:


```elixir
 pie = 3.14
```

```elixir
 case "cherry pie" do
```
Outra característica interessante do `case/2` é o seu suporte para cláusulas de guarda:

_Este exemplo vem diretamente do [Guia Introdutório](http://elixir-lang.org/getting-started/case-cond-and-if.html#case) oficial do Elixir._


```elixir
 case {1, 2, 3} do
```
Verifique a documentação oficial sobre [Expressões permitidas em cláusulas guard](https://hexdocs.pm/elixir/guards.html#list-of-allowed-expressions).


## cond

Quando necessitamos associar condições, e não valores, nós podemos recorrer ao `cond/1`; Isso é semelhante ao `else if` ou `elsif` de outras linguagens:

_Este exemplo vem diretamente do [Guia Introdutório](http://elixir-lang.org/getting-started/case-cond-and-if.html#cond) oficial do Elixir._


```elixir
 cond do
```

Como `case/2`, `cond/1` irá gerar um erro caso não seja achado associação. Para lidar com isso, nós podemos definir a condição para `true`:


```elixir
 cond do
```

## with

A forma especial `with/1` é útil quando tentamos usar `case/2` de maneira aninhada ou em situações que não é possível encadear funções. A expressão `with/1` é composta de palavras-chaves, generators e finalmente uma expressão.

Iremos discutir generators na [lição sobre list comprehensions](/pt/lessons/basics/comprehensions) para comparar o lado direito do operador `<-` com o lado esquerdo.

Vamos começar com um exemplo simples de `with/1` e então vamos olhar em algo mais:


```elixir
 user = %{first: "Sean", last: "Callan"}
```

```elixir
 with {:ok, first} <- Map.fetch(user, :first),
```

Quando uma expressão falha em achar um padrão, o valor da expressão que falhou será retornado:


```elixir
 user = %{first: "doomspork"}
```

```elixir
 with {:ok, first} <- Map.fetch(user, :first),
```

Agora vamos olhar um exemplo maior sem `with/1` e então ver como nós podemos refatorar:


```elixir
case Repo.insert(changeset) do
  {:ok, user} ->
    case Guardian.encode_and_sign(user, :token, claims) do
      {:ok, token, full_claims} ->
        important_stuff(token, full_claims)

      error ->
        error
    end

  error ->
    error
end
```

Quando utilizamos `with/1` acabamos com um código que é facilmente entendido e possui menos linhas:


```elixir
with {:ok, user} <- Repo.insert(changeset),
     {:ok, token, full_claims} <- Guardian.encode_and_sign(user, :token, claims) do
  important_stuff(token, full_claims)
end
```

A partir do Elixir 1.3, `with/1`  suporta `else`:


```elixir
import Integer

m = %{a: 1, c: 3}

a =
  with {:ok, number} <- Map.fetch(m, :a),
    true <- is_even(number) do
      IO.puts "#{number} divided by 2 is #{div(number, 2)}"
      :even
  else
    :error ->
      IO.puts("We don't have this item in map")
      :error

    _ ->
      IO.puts("It is odd")
      :odd
  end
```

Isso ajuda a lidar com erros provendo padrões parecido com o `case`. O valor passado para o else é o primeiro que não foi correspondido com o padrão em uma expressão.
