# কনকারেন্সী

## প্রসেস

এরল্যাং ভি এম এর প্রসেস গুলো অনেক হালকা এবং সব সিপিউতেই রান হয়। 
যদিও তারা দেখতে অনেকটা ন্যাটিভ থ্রেডস এর মতো, তবে তারা আরও সরল এছাড়া একটি এলিক্সির এপ্লিকেশনে হাজার হাজার কনকারেন্ট প্রসেস থাকাটা অলীক নয়।

`spawn` ব্যবহার করে খুব সহজেই নতুন প্রসেস তৈরি করা যায়, যা একটা এননিমাস অথবা নেমড ফাংশন নেয়। 
যখন আমরা একটা নতুন প্রসেস তৈরি করি তখন এটা একটা _প্রসেস আইডেন্টিফায়ার_ রিটার্ন করে, সংক্ষেপে PID, যা দিয়ে প্রসেসটিকে আমাদের এপ্লিকেশনের মধ্যে চিহ্নিত করা যায়।

শুরু করার জন্যে, আমরা একটা মডিউল এবং ফাংশন তৈরি করবো রান করার জন্যেঃ


```elixir
 Example.add(2, 3)
```

ফাংশনটি এসিনক্রোনাস ভাবে রান করার জন্যে আমরা ব্যবহার করবো `spawn/3`:


```elixir
 spawn(Example, :add, [2, 3])
```

### মেসেজ পাসিং

প্রসেস গুলো নিজেদের মধ্যে কথা বলার জন্যে, মেসেজ পাসিং ব্যবহার করে থাকে। 
মূলতঃ দুইটা কম্পোনেন্ট এর সাহায্যেঃ `send/2` এবং `receive`
`send/2` ফাংশনের সাহায্যে আমরা PID ব্যবহার করে মেসেজ পাঠাতে পারি। 
মেসেজ পেতে আমরা, `receive` ফাংশন ব্যবহার করি যাতে মেসেজ ম্যাচ করা যায়। 
কোনো মিল না পাওয়া গেলে এক্সিকিউশন বন্ধ না হয়ে বরং চলতেই থাকে, অবিরত।  


```elixir
 pid = spawn(Example, :listen, [])
```

```elixir
 send pid, {:ok, "hello"}
```

```elixir
 send pid, :ok
```

আপনি হয়তো লক্ষ্য করেছেন, `listen/0` ফাংশনটি রিকারসিভ। এই কারণে প্রসেস গুলো অনেকগুলো মেসেজ হ্যান্ডল করতে সমর্থ হয়। 
রিকারশন ছাড়া, আমাদের প্রসেস প্রথম মেসেজ পাওয়ার পরেই শেষ হয়ে যেতো। 

### প্রসেস লিঙ্কিং 

`spawn` এর একটি সমস্যা হলো প্রসেস ক্র্যাশ করলে তা জানা যায় না।
এটা জানতে আমাদের `spawn_link` এর সাহায্যে প্রসেসকে লিংক করতে হবে।
দুইটি লিংকড প্রসেস একে অপরের এক্সিট নোটিফিকেশন পেয়ে থাকেঃ


```elixir
 spawn(Example, :explode, [])
```

```elixir
 spawn_link(Example, :explode, [])
```

কখনো কখনো আমরা চাই না, আমাদের বর্তমান প্রসেস কোনো লিঙ্কড প্রসেসের কারণে ক্র্যাশ করুক।
এ জন্যে আমাদের `Process.flag/2` ব্যবহার করে এক্সিটকে আটকাতে হবে। 
এটা এরল্যাং এর [process_flag/2](http://erlang.org/doc/man/erlang.html#process_flag-2) ফাংশনটি ব্যবহার করে `trap_exit` ফ্ল্যাগটি পাওয়ার জন্যে। যখন এই ফ্ল্যাগটি পাওয়া যায় (`trap_exit` যখন `true` হয়), তখন টাপল মেসেজ আকারে এক্সিট সিগন্যাল পাওয়া যায়ঃ `{:EXIT, from_pid, reason}`। 


```elixir
 Example.run
```

### প্রসেস মনিটরিং

কেমন হয় যদি, আমরা দুটি প্রসেস লিংক না করেই মেসেজ আদান প্রদান করতে চাই? এটা করতে আমরা `spawn_monitor` ব্যবহার করতে পারি।
যখন আমরা প্রসেসকে মনিটর করি তখন আমরা প্রসেস ক্র্যাশ করলেই মেসেজ পেতে পারি বর্তমান প্রসেস ক্র্যাশ না করে কিংবা ট্র্যাপ এক্সিট ব্যবহার না করে।


```elixir
 Example.run
```

## এজেন্টস 

এজেন্টস ব্যাকগ্রাউন্ড প্রসেস এর স্টেট মেইন্টেইন করার জন্যে একধরণের এবস্ট্র্যাকশন। 
আমাদের এপ্লিকেশন এবং নোডের মধ্যে থাকা প্রসেস থেকেই আমরা তাদেরকে এক্সেস করতে পারি।
এজেন্ট এর স্টেট ফাংশনের রিটার্ন ভ্যালু দ্বারা নির্ধারিত হয়ঃ


```elixir
 {:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
```

```elixir
 Agent.update(agent, fn (state) -> state ++ [4, 5] end)
```

```elixir
 Agent.get(agent, &(&1))
```

PID ব্যবহার না করেও,শুধুমাত্র এজেন্টের নাম ব্যবহার করেও কোনো এজেন্টকে এক্সেস করা যায়ঃ 


```elixir
 Agent.start_link(fn -> [1, 2, 3] end, name: Numbers)
```

```elixir
 Agent.get(Numbers, &(&1))
```

## টাস্কস 

টাস্কস হলো ফাংশনকে ব্যাকগ্রাউন্ডে রান করে পরবর্তীতে এর রিটার্ন ভ্যালু পাওয়ার একটি পন্থা।
এপ্লিকেশন এর এক্সিকিউশন ব্লক না করেই ব্যয়বহুল অপারেশন করতে টাস্কস এর ব্যবহার অতুলনীয়।


```elixir
 task = Task.async(Example, :double, [2000])
```

```elixir
 Task.await(task)
```
