# Concurrency

## Proses

Proses (process) dalam VM Erlang adalah ringan dan dijalankan lintas CPU.  Walau proses mungkin tampak sebagai native thread, proses sebetulnya lebih sederhana dan bukannya jarang memiliki ribuan proses yang konkuren dalam sebuah aplikasi Elixir.

Cara termudah untuk membuat sebuah proses baru adalah `spawn`, yang menggunakan sebuah fungsi yang bernama maupun yang anonim.  Ketika kita membuat sebuah proses baru, `spawn` mengembalikan sebuah _Process Identifier_, atau PID, untuk mengidentifikasikannya secara unik di dalam aplikasi kita.

Untuk memulai kita akan membuat sebuah modul dan mendefinisikan sebuah fungsi yang kita ingin jalankan:


```elixir
 Example.add(2, 3)
```

Untuk mengevaluasi fungsi tersebut secara asinkron kita gunakan `spawn/3`:


```elixir
 spawn(Example, :add, [2, 3])
```

### Pengiriman Pesan

Untuk berkomunikasi, proses-proses bergantung pada pengiriman pesan (message passing).  Ada dua komponen utama: `send/2` and `receive`.  Fungsi `send/2` mengijinkan kita mengirim pesan ke PID.  Untuk mendengarkan kita gunakan `receive` untuk mencocokkan pesan.  Jika tidak ada kecocokan eksekusi berjalan terus.


```elixir
 pid = spawn(Example, :listen, [])
```

```elixir
 send pid, {:ok, "hello"}
```

```elixir
 send pid, :ok
```

### Process Linking

Satu masalah dengan `spawn` adalah cara mengetahui ketika sebuah proses crash.  Untuk itu kita perlu mengkaitkan (link) proses-proses kita menggunakan `spawn_link`.  Dua proses yang terkait akan saling menerima notifikasi exit:


```elixir
 spawn(Example, :explode, [])
```

```elixir
 spawn_link(Example, :explode, [])
```

Terkadang kita tidak ingin proses kita yang terkait untuk mengakibatkan proses yang sekarang ada ikut crash.  Untuk itu kita perlu menjebak (trap) exit.  Ketika menjebak exit proses akan menerima sebagai sebuah pesan tuple: `{:EXIT, from_pid, reason}`.


```elixir
 Example.run
```

### Process Monitoring

Bagaimana jika kita tidak ingin mengkaitkan dua proses tetapi tetap ingin menerima informasi? Untuk itu kita bisa menggunakan pemantauan proses (process monitoring) dengan `spawn_monitor`. Ketika kita memantau sebuah proses keta menerima sebuah pesan jika proses tersebut crash, tanpa akibatkan proses kita yang sedang berjalan ikut crash atau perlu secara eksplisit menjebak exit.


```elixir
 Example.run
```

## Agent

Agent adalah sebuah abstraksi yang melingkupi background process yang menjaga state.  Kita bisa mengakses Agent dari proses lain di dalam aplikasi dan node kita.  State dari Agent kita diset ke return value fungsi kita:


```elixir
 {:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
```

```elixir
 Agent.update(agent, fn (state) -> state ++ [4, 5] end)
```

```elixir
 Agent.get(agent, &(&1))
```

Jika kita memberi nama sebuah Agent kita bisa merujuknya menggunakan nama tersebut dan bukannya PID:


```elixir
 Agent.start_link(fn -> [1, 2, 3] end, name: Numbers)
```

```elixir
 Agent.get(Numbers, &(&1))
```

## Task

Task memberikan cara untuk mengeksekusi sebuah fungsi di background dan menerima hasilnya belakangan.  Task bisa berguna terutama ketika menangani operasi yang mahal (makan waktu lama) tanpa memblok eksekusi aplikasi kita.


```elixir
 task = Task.async(Example, :double, [2000])
```

```elixir
 Task.await(task)
```
