# Keserempakan

## Proses

Proses-proses di dalam Erlang VM adalah ringan dan memanafaatkan kesemua CPU apabila dijalankan.  Walaupun mereka nampak seperti 'native thread',  mereka sebenarnya adalah lebih ringkas dan ianya tidak janggal jika terdapat ribuan proses yang berjalan secara keserempakan di dalam aplikasi Elixir.

Cara paling mudah untuk membuat satu proses baru ialah menggunakan `spawn`, yang mengambil satu fungsi tanpa nama atau fungsi bernama.  Apabila kita membuat satu proses baru ia akan memulangkan satu _Process Identifier_, atau PID,  sebagai pengenalan unik untuk proses itu di dalam aplikasi kita.

Untuk bermula kita akan membuat satu modul dan takrifkan satu fungsi yang kita mahu jalankan:


```elixir
 Example.add(2, 3)
```

Untuk menjalankan fungsi tersebut secara tak segerak(asynchronous) kita gunakan `spawn/3`:


```elixir
 spawn(Example, :add, [2, 3])
```

### Pengagihan Mesej

Untuk berkomunikasi, proses-proses bergantung kepada pengagihan mesej.  Terdapat dua komponen penting di dalam pengagihan mesej, `send/2` dan `receive/2`.  Fungsi `send/2` mengupayakan kita untuk menghantar mesej kepada PID.  Untuk mengawasi penerimaan mesej, kita gunakan `receive`.  


```elixir
 pid = spawn(Example, :listen, [])
```

```elixir
 send pid, {:ok, "hello"}
```

```elixir
 send pid, :ok
```

### Perangkaian Proses

Fungsi `spawn` mempunyai satu masalah iaitu untuk mengetahui apabila sesatu proses itu runtuh(crash).  Untuk itu kita perlu untuk merangkaikan proses-proses kita dengan menggunakan `spawn_link`.  Dua proses yang dirangkaikan akan menerima 'exit notification' dari satu sama lain:


```elixir
 spawn(Example, :explode, [])
```

```elixir
 spawn_link(Example, :explode, [])
```

Kadang-kadang kita tidak mahu proses yang dirangkaikan meruntuhkan proses sedia ada.  Untuk itu kita perlu untk memerangkap 'exit' tersebut.  'Exit' yang diperangkap akan diterima sebagai satu mesej dalam bentuk tuple: `{:Exit, from_pid, reason}`.


```elixir
 Example.run
```

### Pengawasan Proses

Bagaiana pula jika kita tidak mahu merangkaikan dua proses tetapi masih diberitahu mengenai keadaan semasa proses-proses tersebut?  Untuk itu kita boleh membuat pengawasan proses dengan menggunakan `spawn_monitor`.  Apabila mengawasi satu proses, kita akan mendapat satu mesej jika proses tersebut runtuh tanpa meruntuhkan sama proses semasa kita atau tanpa memerlukan 'exit' itu diperangkap.


```elixir
 Example.run
```

## Agent

Agent adalah sejenis peniskalaan(abstraction) proses-proses 'background' yang menyelenggara keadaan semasa(state).  Mereka boleh dicapai daripada proses-proses lain dari dalam aplikasi dan nod kita.  Keadaan semasa(state) Agent kita ditetapkan kepada nilai yang dipulangkan oleh fungsi-fungsi kita:  


```elixir
 {:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
```

```elixir
 Agent.update(agent, fn (state) -> state ++ [4, 5] end)
```

```elixir
 Agent.get(agent, &(&1))
```

Apabila kita menamakan satu Agent, ia boleh dirujuk sebagai Agent dan tidak melalui PID-nya.


```elixir
 Agent.start_link(fn -> [1, 2, 3] end, name: Numbers)
```

```elixir
 Agent.get(Numbers, &(&1))
```

## Task

'Task' menyediakan satu cara untk menjalankan satu fungsi di 'background' dan menerima nilai yang dipulangkan kemudian.  Ianya amat berguna apabila menguruskan operasi-operasi yang berat tanpa merencatkan perjalanan aplikasi.


```elixir
 task = Task.async(Example, :double, [2000])
```

```elixir
 Task.await(task)
```
