# Hata işleme

## Hata işleme

Hataları işleyebilmemiz için bu hataları oluşturmamız gerekiyor ve bunu yapmanın en basit yolu `raise/1` fonksiyonudur:


```elixir
 raise "Oh no!"
```

Eğer tipi ve mesajı belirtmek istiyorsak `raise/2` fonksiyonunu kullanmalıyız:


```elixir
 raise ArgumentError, message: "the argument value is invalid"
```

Bir hatanın meydana gelebileceğini bildiğimiz zaman, `try/rescue` ve desen eşleştirmesi(pattern matching) ile neler olup bittiğine bakabilirsiz:


```elixir
 try do
```

Tek bir `rescue` ile birden fazla hatayı yakalayabilmek mümkündür:


```elixir
try do
  opts
  |> Keyword.fetch!(:source_file)
  |> File.read!()
rescue
  e in KeyError -> IO.puts("missing :source_file option")
  e in File.Error -> IO.puts("unable to read source file")
end
```

## After

Bazen, hatadan bağımsız olarak `try/rescue` fonksiyonumuzdan sonra bir miktar işlem yapmamız gerekebilir. İşte bunun için `try/after` var.  Ruby'ye aşina iseniz, bu, `begin/rescue/ensure` ya da Java'da ki `try/catch/finally` türevlerine benzer:


```elixir
 try do
```

Bu, kapatılması gereken dosyalarda ve/veya bağlantılarda kullanılır:


```elixir
{:ok, file} = File.open("example.json")

try do
  # Do hazardous work
after
  File.close(file)
end
```

## New Errors

Elixir yerleşik olarak, `RuntimeError` gibi bir çok hata türünü içeriyor olsa da, belirli bir şeye ihtiyacımız varsa, kendi hata yakalama durumumuzu belirtmemiz gerekir. Varsayılan hata mesajını ayarlamak için `:message` seçeneğini rahatça kabul eden `defexception/1` fonksiyonu ile yeni bir hata mesajı oluşturmak aşağıdaki gibidir ve kolaydır:


```elixir
defmodule ExampleError do
  defexception message: "an example error has occurred"
end
```

Şimdi oluşturduğumuz bu yeni hatamızı kullanalım.


```elixir
 try do
```

## Throws

Elixir'deki hatalarla çalışmak için başka bir mekanizma olarak da `throw` ve `catch` kullanabilirsiniz. Pratikte, bunlar daha yeni Elixir kodlarında kullanılır ve çok seyrek görülür, fakat yine de bunları bilmek ve gerekti zaman kullanmak işlerinizi oldukça kolaylaştıracaktır.

`throw/1` fonksiyonu bize, `catch` yapabileceğimiz ve kullanabileceğimiz belirli bir değerle yürütmeden çıkma yeteneği verir:


```elixir
 try do
```

Bahsedildiği gibi, `throw/catch` oldukça nadir kullanılır ve kütüphaneler yeterli API'ları sağlamada başarısız olduklarında stopgaps(geçici) olarak bulunurlar.

## Exiting

Elixir'in bize sağladığı son hata mekanizması `exit`. Çıkış sinyalleri, bir süreç sonlandığında ortaya çıkar ve Elixir'in hata toleransının önemli bir parçasını oluşturur.

Açıkça çıkmak istediğinizi belirtmek için `exit/1` kullanabilirsiniz:


```elixir
 spawn_link fn -> exit("oh no") end
```

`try/catch` ile çıkış yapmak mümkün olsa da, kullanımı _oldukça_ nadirdir. Hemen hemen her durumda, denetim otoritesinin süreç çıkışını ele alması avantajlıdır:


```elixir
 try do
```
