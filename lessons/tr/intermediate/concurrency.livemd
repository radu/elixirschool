# Concurrency

## Süreçler

Erlang VM'deki işlemler hafiftir ve tüm CPU'larda çalışır. Yerel ileti dizileri gibi görünseler de, daha basittirler ve bir Elixir uygulamasında binlerce eşzamanlı işlemin olması hiçte zor değildir.

Yeni bir süreç oluşturmanın en kolay yolu, adsız veya adlandırılmış bir fonksiyon alan `spawn`, Yeni bir süreç oluşturduğumuzda, kendi uygulamalarımızda benzersiz bir şekilde tanımlamak için bir _Process Identifier_ veya PID değerini döndürür.

Başlamak için bir modül oluşturacağız ve çalıştırmak istediğimiz bir fonksiyon tanımlayacağız:


```elixir
 Example.add(2, 3)
```

Eş zamansız bir fonksiyon değerlendirmek için `spawn/3` kullanırız:


```elixir
 spawn(Example, :add, [2, 3])
```

### İleti Geçişi

İletişim kurmak için süreçler iletilen iletilere güvenir. Bunun iki ana bileşeni var. Bunlar: `send/2` ve `receive`.

`send/2` fonksiyonu, PID'lere mesaj göndermemize izin verir. Mesajları dinleyebilmek için  `receive`'ı kullanın. Eşleşme bulunamazsa, yürütme kesintisiz olarak devam eder.


```elixir
 pid = spawn(Example, :listen, [])
```

```elixir
 send pid, {:ok, "hello"}
```

```elixir
 send pid, :ok
```

`listen/0` tekrarlı olduğunu fark edebilirsiniz, bu sayede sürecimizin birden çok mesajı ele almasını sağlayabiliriz. Yineleme olmadan, ilk mesajın işlenmesinden sonra işlemimiz kesilirdi.

### Süreç bağlantısı

`spawn` ile ilgili problem, işlemin ne zaman çökeceğini bilmektir. Bunun için süreçlerimizi `spawn_link` kullanarak bağlamamız gerekiyor.

One problem with `spawn` is knowing when a process crashes.  For that we need to link our processes using `spawn_link`. İki bağlantılı bir süreç birbirinden aşağıdaki örnektede görebileceğiniz gibi bir çıkış bildirimi alır:


```elixir
 spawn(Example, :explode, [])
```

```elixir
 spawn_link(Example, :explode, [])
```

Bazen bizim bağlantılı sürecimizin şu anki çöküşünü istemiyoruz. Bunun için `Process.flag/2` kullanarak çıkışları yakalamamız gerekiyor. `trap_exit` bayrağı için erlang'ın [process_flag/2](http://erlang.org/doc/man/erlang.html#process_flag-2) fonksiyonunu kullanabiliriz. Çıkışları yakalarken (`trap_exit` değeri `true` olarak ayarlanır), çıkış sinyalleri bir demet mesajı olarak şu şekilde alınacaktır: `{: EXIT, from_pid, reason}`


```elixir
 Example.run
```

### Süreç İzleme

Ya iki süreci birbirine bağlamak istemiyorsak, yine de haberdar edilmek istiyorsak? Bunun için `spawn_monitor` ile süreci izleyebiliriz. Bir süreci izlediğimizde, sürecin çökmesi veya sürecin beklenmedik bir biçimde çökmesi ile bir ileti alırız.


```elixir
 Example.run
```

## Ajanlar

Ajanlar durumları koruyan arka plan süreçleri etrafında uygulanan bir soyutlamadır. Uygulamalarımızdaki ve düğümümüzdeki diğer süreçlerden onlara erişebiliriz. Ajanımızın durumu, fonksiyonumuzun geri dönüş değerine ayarlanır:


```elixir
 {:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
```

```elixir
 Agent.update(agent, fn (state) -> state ++ [4, 5] end)
```

```elixir
 Agent.get(agent, &(&1))
```

Bir Ajan ismini verdiğimiz zaman, PID'in yerine buna başvurabiliriz:


```elixir
 Agent.start_link(fn -> [1, 2, 3] end, name: Numbers)
```

```elixir
 Agent.get(Numbers, &(&1))
```

## Görevler

Görevler, arka planda bir fonksiyonu yürütmek ve daha sonra geri dönüş değerini almak için size bir yol sağlar. İşlem yükü çok olan durumları ele almamız gerekirse özellikle görevler oldukça işinize yarayacaktır.


```elixir
 task = Task.async(Example, :double, [2000])
```

```elixir
 Task.await(task)
```
