# Сопоставление с образцом

## Оператор сопоставления

В языке Elixir оператор `=` на самом деле является оператором сопоставления по аналогии со знаком равенства в алгебре. Его использование превращает выражение в уравнение, и Elixir сопоставляет левую часть выражения с правой. В случае успешного сопоставления вернётся само решённое уравнение, иначе возникнет ошибка:


```elixir
 x = 1
```

Простейшее сопоставление:


```elixir
 1 = x
```

```elixir
 2 = x
```

Сопоставление с коллекциями:


```elixir
 list = [1, 2, 3]
```

```elixir
 [1, 2, 3] = list
```

```elixir
 [] = list
```

```elixir
 [1 | tail] = list
```

```elixir
 tail
```

```elixir
 [2|_] = list
```

```elixir
 {:ok, value} = {:ok, "Successful!"}
```

```elixir
 value
```

```elixir
 {:ok, value} = {:error}
```

## Фиксирующий оператор

Мы уже разобрались, что оператор сопоставления делает присвоение в тех случаях, когда левая сторона сопоставляемого включает переменную. В некоторых случаях повторное присвоение переменной является нежелательным. В таких случаях используется "фиксирующий оператор" `^`.

Когда мы закрепляем переменную с его помощью, сопоставление происходит с имеющимся значением переменной вместо присвоения нового значения:


```elixir
 x = 1
```

```elixir
 ^x = 2
```

```elixir
 {x, ^x} = {2, 1}
```

```elixir
 x
```

В версии Elixir 1.2 добавлена поддержка этого оператора в ключи ассоциативных массивов и функциональные ветвления:


```elixir
 key = "hello"
```

```elixir
 %{^key => value} = %{"hello" => "world"}
```

```elixir
 value
```

```elixir
 %{^key => value} = %{:hello => "world"}
```

Пример использования в функциональном ветвлении:


```elixir
 greeting = "Hello"
```

```elixir
 greet = fn
```

```elixir
 greet.("Hello", "Sean")
```

```elixir
 greet.("Mornin'", "Sean")
```

```elixir
 greeting
```

Обратите внимание, что в примере с `"Mornin'"` переназначение переменной `greeting` в `"Mornin'"` происходит только в контексте функции. За её пределами значение `greeting` всё так же `"Hello"`.
