# Строковые метки

## Обзор строковых меток

Elixir предоставляет альтернативный синтаксис для представления литералов и работы с ними.
Строковая метка начинается с тильды `~`, за которой следует символ.
Ядро Elixir уже включает в себя несколько встроенных строковых меток, однако мы можем создавать свои при необходимости расширить возможности языка.

Список доступных строковых меток:

  - `~C` Создаёт список символов **без** экранирования и интерполяции
  - `~c` Создаёт список символов **с** экранированием и интерполяцией
  - `~R` Создаёт регулярное выражение **без** экранирования и интерполяции
  - `~r` Создаёт регулярное выражение **с** экранированием и интерполяцией
  - `~S` Создаёт строку **без** экранирования и интерполяции
  - `~s` Создаёт строку **с** экранированием и интерполяцией
  - `~W` Создаёт список слов  **без** экранирования и интерполяции
  - `~w` Создаёт список слов **с** экранированием и интерполяцией
  - `~N` Создаёт структуру `NaiveDateTime`

Список доступных разделителей:

  - `<...>` Пара угловых скобок
  - `{...}` Пара фигурных скобок
  - `[...]` Пара квадратных скобок
  - `(...)` Пара круглых скобок
  - `|...|` Пара вертикальных черт
  - `/.../` Пара косых черт
  - `"..."` Пара двойных кавычек
  - `'...'` Пара одинарных кавычек

### Список символов

Строковые метки `~c` и `~C` создают списки символов.
Например:


```elixir
 ~c/2 + 7 = #{2 + 7}/
```

```elixir
 ~C/2 + 7 = #{2 + 7}/
```

Видно, что строчная `~c` интерполирует вычисление, а прописная `~C` — нет.
Далее мы увидим, что во всех встроенных строковых метках встречается такое разделение на строчные и прописные.

### Регулярные выражения

Строковые метки `~r` и `~R` используются для представления регулярных выражений.
Мы можем создавать их для использования на лету, либо для применения функций `Regex`.
Например:


```elixir
 re = ~r/elixir/
```

```elixir
 "Elixir" =~ re
```

```elixir
 "elixir" =~ re
```

Как мы видим, в первом тесте на равенство слово `Elixir` не соответствует регулярному выражению.
Дело в том, что оно начинается с заглавной буквы.
Elixir поддерживает регулярные выражения PCRE (Perl Compatible Regular Expressions), поэтому мы можем добавить `i` в конец нашей строковой метки, чтобы отключить регистрозависимость.


```elixir
 re = ~r/elixir/i
```

```elixir
 "Elixir" =~ re
```

```elixir
 "elixir" =~ re
```

Также Elixir поддерживает [Regex](https://hexdocs.pm/elixir/Regex.html) API, основанный на библиотеке регулярных выражений из Erlang.
Попробуем воспользоваться `Regex.split/2` на строковой метке регулярного выражения:


```elixir
 string = "100_000_000"
```

```elixir
 Regex.split(~r/_/, string)
```

Как мы видим, благодаря строковой метке `~r/_/` выражение `"100_000_000"` разделилось на части по символу подчёркивания.
Функция `Regex.split` возвращает список.

### Строка

Строковые метки `~s` и `~S` используются для создания строк.
Например:


```elixir
 ~s/the cat in the hat on the mat/
```

```elixir
 ~S/the cat in the hat on the mat/
```

Но в чём разница? Отличие такое же, как в строковых метках списка символов,
которые мы уже рассмотрели ранее — интерполяция и экранирование.
Посмотрим на ещё один пример:


```elixir
 ~s/welcome to elixir #{String.downcase "SCHOOL"}/
```

```elixir
 ~S/welcome to elixir #{String.downcase "SCHOOL"}/
```

### Список слов

Строковая метка списка слов иногда может оказаться весьма полезной.
Эта возможность упростит код и сэкономит время.
Возьмём простой пример:


```elixir
 ~w/i love elixir school/
```

```elixir
 ~W/i love elixir school/
```

Всё, что написано между разделителями, разбивается по пробелу и сохраняется в список.
Однако, с виду между этими примерами нет разницы.
Она вновь заключается в интерполяции и экранировании.
Посмотрим на следующий пример:


```elixir
 ~w/i love #{'e'}lixir school/
```

```elixir
 ~W/i love #{'e'}lixir school/
```

### NaiveDateTime

[NaiveDateTime](https://hexdocs.pm/elixir/NaiveDateTime.html) используется для быстрого создания структуры, представляющей собой `DateTime` **без** часового пояса.

Как правило, стоит избегать создания `NaiveDateTime` напрямую.
Однако это может пригодиться для сопоставления с образцом.
Например:


```elixir
 NaiveDateTime.from_iso8601("2015-01-23 23:50:07") == {:ok, ~N[2015-01-23 23:50:07]}
```

## Создание строковых меток

Одной из целей разработки языка Elixir было создать гибкий и расширяемый язык программирования.
Потому неудивительно, что мы можем создавать свои строковые метки.
В этом примере мы создадим строковую метку, которая превращает все символы строки в заглавные.
Так как в ядре Elixir уже есть функция (`String.upcase/1`), то сделаем нашу строковую метку на её основе.


```elixir
 defmodule MySigils do
```

```elixir
 import MySigils
```

```elixir
 ~u/elixir school/
```

Для начала объявим модуль с именем `MySigils` и внутри него создадим функцию `sigil_u`.
Мы используем `~u`, потому что она не занята в пространстве строковых меток.
`_u` означает, что мы хотим использовать символ `u` после тильды.
Функция должна принимать два аргумента: вводимое значение и список.
