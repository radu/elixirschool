# Коллекции

## Списки

Списки — это обычные коллекции значений. Они могут включать различные типы и неуникальные значения.


```elixir
 [3.14, :pie, "Apple"]
```

Списки в Elixir являются односвязными.
Это означает, что получение длины списка имеет линейную сложность (`O(n)`).
По этой причине добавлять элементы в начало списка намного быстрее, чем в конец.


```elixir
 list = [3.14, :pie, "Apple"]
```

```elixir
 ["π" | list]
```

```elixir
 list ++ ["Cherry"]
```

### Объединение списков

Для объединения списков используется оператор `++/2`:


```elixir
 [1, 2] ++ [3, 4, 1]
```

Небольшая заметка по поводу формата имён (`++/2`), использованного выше:
в Elixir (и Erlang, на основе которого сделан Elixir) имена функций и операторов состоят из двух частей: непосредственно имени (в этом случае `++`) и _арности_.
Арность — одно из ключевых понятий Elixir и Erlang.
Это количество аргументов, принимаемых функцией (в этом случае два).
Арность и имя соединены через слэш. Позже мы разберём это подробнее.

### Вычитание списков

Оператор `--/2` предоставляет возможность вычитать списки. Не будет ошибкой вычитание отсутствующего элемента:


```elixir
 ["foo", :bar, 42] -- [42, "bar"]
```

Обратите внимание на повторяющиеся значения.
Из левого списка удаляется только первое вхождение каждого элемента правого списка:


```elixir
 [1,2,2,3,2,3] -- [1,2,3,2]
```

**Замечание:** Для сопоставления элементов используется [строгое сравнение](/ru/lessons/basics/basics#сравнения). Например:


```elixir
 [2] -- [2.0]
```

```elixir
 [2.0] -- [2.0]
```

### Голова / Хвост

При использовании списков очень частой операцией является получение "головы" и "хвоста" списка.
"Головой" является первый элемент, а "хвостом" — остальные элементы.
Для работы с ними Elixir предоставляет два оператора — `hd` и `tl`:


```elixir
 hd [3.14, :pie, "Apple"]
```

```elixir
 tl [3.14, :pie, "Apple"]
```

Того же результата можно добиться с использованием оператора cons — `|`. Мы будем часто его встречать в последующих уроках.


```elixir
 [head | tail] = [3.14, :pie, "Apple"]
```

```elixir
 head
```

```elixir
 tail
```

## Кортежи

Кортежи похожи на списки, но хранятся в памяти последовательно.
Это даёт возможность быстро получить определенный элемент и длину кортежа. Но изменения становятся "дорогими", так как для этого создаваемый кортеж должен быть целиком скопирован в новую область памяти.
Кортежи определяются с помощью фигурных скобок:


```elixir
 {3.14, :pie, "Apple"}
```

Часто они используются как механизм для получения дополнительной информации из функций. Полезность этого будет видна позже, когда мы будем углубляться в [сопоставление с образцом](/ru/lessons/basics/pattern_matching):


```elixir
 File.read("path/to/existing/file")
```

```elixir
 File.read("path/to/unknown/file")
```

## Ключевые списки

Ключевые списки и ассоциативные массивы являются имплементациями ассоциативных коллекций в Elixir.
В Elixir ключевые списки — это специальные списки из двухэлементных кортежей, первым элементом которых является атом. По скорости они идентичны спискам.


```elixir
 [foo: "bar", hello: "world"]
```

```elixir
 [{:foo, "bar"}, {:hello, "world"}]
```

Три характеристики этой структуры данных показывают её важность:

+ Ключи являются атомами.
+ Ключи имеют свой порядок.
+ Ключи необязательно должны быть уникальными.

Поэтому она часто используется для передачи параметров в функции.

## Ассоциативные массивы

В Elixir ассоциативный массив — это хранилище типа ключ-значение с возможностью быстрого получения информации по ключу.
В отличие от ключевых списков, они поддерживают любой тип ключей и не сохраняют порядок следования.
Ассоциативный массив объявляется с помощью синтаксиса `%{}`:


```elixir
 map = %{:foo => "bar", "hello" => :world}
```

```elixir
 map[:foo]
```

```elixir
 map["hello"]
```

С версии Elixir 1.2 переменные поддерживаются в качестве ключей:


```elixir
 key = "hello"
```

```elixir
 %{key => "world"}
```

Если в эту структуру данных добавляется новый ключ, он перепишет старое значение:


```elixir
 %{:foo => "bar", :foo => "hello world"}
```

Как видно из вывода команды выше, также есть специальный короткий синтаксис для ассоциативных массивов, ключами которых являются только атомы:


```elixir
 %{foo: "bar", hello: "world"}
```

```elixir
 %{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}
```

Также существует специальный синтаксис для получения значений ключей-атомов:


```elixir
 map = %{foo: "bar", hello: "world"}
```

```elixir
 map.hello
```

Ещё одно интересное свойство ассоциативных массивов — это особенный синтаксис для обновления:


```elixir
 map = %{foo: "bar", hello: "world"}
```

```elixir
 %{map | foo: "baz"}
```

**Примечание**: такой синтаксис работает только для обновления существующих ключей в ассоциативных массивах! Если указанного ключа нет, возникнет исключение `KeyError`.

Для создания нового ключа используйте [`Map.put/3`](https://hexdocs.pm/elixir/Map.html#put/3)


```elixir
 map = %{hello: "world"}
```

```elixir
 %{map | foo: "baz"}
```

```elixir
 Map.put(map, :foo, "baz")
```
