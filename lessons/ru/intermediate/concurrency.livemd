# Параллелизм

## Процессы

Процессы в Erlang VM легковесны и выполняются на всех процессорах.
Они могут показаться похожими на нативные потоки, но они проще, и вполне нормально иметь тысячи параллельных процессов в одном приложении Elixir.

Простейший способ создать новый процесс это функция `spawn`, принимающая анонимную или именованную функцию.
Когда мы создаём новый процесс, он возвращает _Идентификатор процесса_, или PID, для однозначного определения внутри нашего приложения.

Для начала создадим модуль и опишем функцию, которую мы хотели бы запустить:


```elixir
 Example.add(2, 3)
```

Чтобы выполнить функцию асинхронно, воспользуемся `spawn/3`:


```elixir
 spawn(Example, :add, [2, 3])
```

### Передача сообщений

Для взаимодействия между собой процессы используют сообщения.
Для этого существует две части: `send/2` и `receive`.
Функция `send/2` позволяет отправлять сообщения PID'y.
Для получения и проверки сообщений используется `receive`.
Если при проверке совпадение не будет найдено, выполнение продолжится.


```elixir
 pid = spawn(Example, :listen, [])
```

```elixir
 send pid, {:ok, "hello"}
```

```elixir
 send pid, :ok
```

Стоит заметить, что функция `listen/0` рекурсивна (вызывает саму себя), что позволяет этому процессу обработать несколько сообщений.
Без этого вызова процесс завершит свою работу после обработки первого сообщения.

### Связывание процессов

Одна из проблем при использовании `spawn` — узнать о выходе процесса из строя.
Для этого мы свяжем наши процессы с помощью `spawn_link`.
Два связанных процесса будут получать друг от друга уведомления о завершении:


```elixir
 spawn(Example, :explode, [])
```

```elixir
 spawn_link(Example, :explode, [])
```

Иногда мы не хотим, чтобы связанный процесс завершал текущий.
Для этого нужно перехватывать попытки завершения с помощью функции `Process.flag/2`.
Она использует функцию [process_flag/2](http://erlang.org/doc/man/erlang.html#process_flag-2) Erlang с флагом `trap_exit`. Если перехват включён (`trap_exit` равно `true`), перехваченные попытки будут получены в виде сообщения-кортежа: `{:EXIT, from_pid, reason}`.


```elixir
 Example.run
```

### Мониторинг процессов

Но что делать, если мы не хотим связывать два процесса, но при этом хотим получать информацию? Можно воспользоваться `spawn_monitor` для мониторинга процесса.
При наблюдении за процессом мы получаем сообщения, если процесс выйдет из строя, без завершения текущего процесса и необходимости явно перехватывать попытки завершения.


```elixir
 Example.run
```

## Агенты

Агенты — абстракция над фоновыми процессами, сохраняющими состояние.
Мы можем получить доступ к ним из другого процесса нашего приложения.
Состояние агента устанавливается равным возвращаемому значению нашей функции:


```elixir
 {:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
```

```elixir
 Agent.update(agent, fn (state) -> state ++ [4, 5] end)
```

```elixir
 Agent.get(agent, &(&1))
```

Если мы зададим имя агенту, то сможем обращаться к нему, используя имя, а не PID:


```elixir
 Agent.start_link(fn -> [1, 2, 3] end, name: Numbers)
```

```elixir
 Agent.get(Numbers, &(&1))
```

## Задачи

Задачи предоставляют возможность выполнять функцию в фоновом режиме и получать её значение потом.
Они могут быть особенно полезны при обработке дорогостоящих операций без блокировки выполнения приложения.


```elixir
 task = Task.async(Example, :double, [2000])
```

```elixir
 Task.await(task)
```
