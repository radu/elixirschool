# Язык запросов

В этом уроке мы будем работать над приложением `Friends` для каталогизации фильмов из [предыдущего урока](/ru/lessons/ecto/associations).

## Получение записей из Ecto.Repo

Напомним, что "репозиторием" в Ecto называется хранилище данных, такое как наша база данных Postgres.
Всё взаимодействие с базой будет происходить посредством этого репозитория.

Для начала мы можем выполнять простые запросы напрямую через `Friends.Repo` с помощью пары полезных функций.

### Получение записей по ID

Мы можем использовать функцию `Repo.get/3`, чтобы получить запись из базы по ID. Эта функция принимает два обязательных аргумента: структуру данных, пригодную для запросов, и ID искомой записи. В качестве результата она возвращает запись в виде структуры, если таковая была найдена. В противном случае возвращается `nil`.

В примере ниже мы получаем фильм с ID = 1:


```elixir
 alias Friends.{Repo, Movie}
```

```elixir
 Repo.get(Movie, 1)
```

Обратите внимание, что первый аргумент, передаваемый в `Repo.get/3`, – это наш модуль `Movie`. Мы называем `Movie` "пригодным для запросов", потому что он определяет схему данных при помощи `Ecto.Schema`. За счёт этого `Movie` реализует протокол `Ecto.Queryable`. Этот протокол позволяет преобразовывать структуры данных в запросы `Ecto.Query`, которые затем используются для получения данных из репозитория. Дальше мы подробнее остановимся на запросах.

### Получение записей по атрибуту

Мы также можем получать данные по заданным критериям при помощи функции `Repo.get_by/3`. Она принимает два значения: подходящую структуру и условие для запроса. `Repo.get_by/3` в качестве результата возвращает одну запись из репозитория. Вот пример:


```elixir
 Repo.get_by(Movie, title: "Ready Player One")
```

Однако если нам нужно использовать более сложные запросы, либо получать _все_ подходящие под условие записи, нам понадобится модуль `Ecto.Query`.

## Написание запросов с Ecto.Query

Модуль `Ecto.Query` предоставляет собственный язык написания запросов для доступа к данным репозиториев.

### Создание запросов при помощи Ecto.Query.from/2

Запрос можно создавать при помощи макроса `Ecto.Query.from/2`. Эта функция принимает два аргумента: выражение и необязательный ключевой список. Попробуем создать максимально простой запрос для получения всех фильмов из нашего репозитория:


```elixir
 import Ecto.Query
```

```elixir
 query = from(Movie)
```

Чтобы выполнить запрос, воспользуемся функцией `Repo.all/2`. Она принимает структуру запроса Ecto в качестве обязательного аргумента и возвращает все записи, удовлетворяющие условиям.


```elixir
 Repo.all(query)
```

#### Запросы без привязок

Пример выше не включает в себя самую мякотку языка SQL. Очень часто мы хотим получить из базы только определённые поля или отфильтровать записи по какому-то критерию. Давайте получим только значения полей `title` и `tagline` всех фильмов с названием `"Ready Player One"`:


```elixir
 query = from(Movie, where: [title: "Ready Player One"], select: [:title, :tagline])
```

```elixir
 Repo.all(query)
```

Обратите внимание, что в результирующих структурах заполнены только поля `tagline` и `title` – это прямое следствие использования блока `select:`.

Запросы вроде этого называют *запросами без привязки* (bindingless), потому что они достаточно просты и не нуждаются в привязках.

#### Привязки в запросах

До этого момента в качестве первого аргумента макроса `from` мы использовали исключительно модуль, реализующий протокол `Ecto.Queryable` (т.е. `Movie`). Но помимо него, мы могли бы использовать особое выражение с `in`:


```elixir
 query = from(m in Movie)
```

В этом случае мы называем `m` *привязкой*. Привязки нам очень пригодятся, т.к. с их помощью можно ссылаться на структуру в других частях запроса. Например, мы можем достать из базы названия всех фильмов с `id` меньше `2`:


```elixir
 query = from(m in Movie, where: m.id < 2, select: m.title)
```

```elixir
 Repo.all(query)
```

Очень важный момент здесь это как изменился результат выполнения запроса. Использование *выражения* с привязкой в `select:` части запроса позволяет нам явным образом указать, в каком виде мы хотим получить данные. С таким же успехом мы можем попросить функцию вернуть нам кортеж:


```elixir
 query = from(m in Movie, where: m.id < 2, select: {m.title})
```

```elixir
 Repo.all(query)
```

В целом хорошей идеей будет всегда начинать с простого запроса и добавлять привязки только когда появляется необходимость сослаться на структуру. Больше про привязки в запросах можно прочитать в [документации](https://hexdocs.pm/ecto/Ecto.Query.html#module-query-expressions)


### Запросы на основе макросов

В предыдущих примерах, чтобы сконструировать запрос, мы использовали ключи `select:` и `where:` в параметрах макроса `from`. Про такой способ говорят, что он *основан на ключах* (keyword-based). Но существует также ещё один способ конструировать запросы – основанный на макросах. Ecto предоставляет макросы для каждого ключевого слова, например `select/3` или `where/3`. Каждый макрос принимает сущность, пригодную для запросов, *явный список привязок* и точно такое же выражение, какое мы использовали бы в предыдущем подходе:


```elixir
 query = select(Movie, [m], m.title)
```

```elixir
 Repo.all(query)
```

Что хорошо в макросах, так это то, что они отлично объединяются в конвейер:


```elixir
 Movie \
```

Обратите внимание, чтобы продолжить запись после разрыва строки, используйте символ `\`.

### Интерполяция в where

Чтобы интерполировать значения в WHERE-части запроса, необходимо использовать `^` или, как его ещё называют, оператор фиксации (pin). Это позволяет нам  _зафиксировать_ значение в переменной и обратиться к нему после, вместо того, чтобы перезаписать переменную.


```elixir
 title = "Ready Player One"
```

```elixir
 query = from(m in Movie, where: m.title == ^title, select: m.tagline)
```

```elixir
 Repo.all(query)
```

### Получение первой и последней записей

Можно получить первую или последнюю запись из репозитория при помощи функций `Ecto.Query.first/2` и `Ecto.Query.last/2`.

Для начала сконструируем запрос при помощи функции `first/2`:


```elixir
 first(Movie)
```

Потом передадим его в `Repo.one/2`, чтобы получить результат:


```elixir
 Movie |> first() |> Repo.one()
```

Функция `Ecto.Query.last/2` используется аналогично:


```elixir
 Movie |> last() |> Repo.one()
```

## Получение связанных данных

### Предзагрузка

Чтобы иметь доступ к записям, связанным при помощи макросов `belongs_to`, `has_many` и `has_one`, нам нужно _предзагрузить_ соответствующие схемы.

Давайте посмотрим, что случится, если мы попытаемся получить актёров из фильма:


```elixir
 movie = Repo.get(Movie, 1)
```

```elixir
 movie.actors
```

Без предзагрузки этого сделать _не получится_. Существует несколько способов выполнить предзагрузку в Ecto.

#### Предзагрузка двумя запросами

Следующий запрос предзагрузит связанные записи _отдельным_ запросом.


```elixir
 Repo.all(from m in Movie, preload: [:actors])
```

Видно, что код выше сделал _два_ запроса к базе данных. Один для всех фильмов, и ещё один для актёров, связанных с фильмами, с определёнными ID.


#### Предзагрузка одним запросом
Можно избавиться от лишнего запроса следующим способом:


```elixir
 query = from(m in Movie, join: a in assoc(m, :actors), preload: [actors: a])
```

```elixir
 Repo.all(query)
```

Как видим, это позволило вместить всё в один запрос к базе. Это также позволит нам фильтровать в одном запросе как фильмы, так и актёров. Например, при помощи `join` можно получить все фильмы, где актёры удовлетворяют определённому условию. Что-то в этом роде:


```elixir
Repo.all from m in Movie,
  join: a in assoc(m, :actors),
  where: a.name == "John Wayne",
  preload: [actors: a]
```

Подробнее на `join` остановимся чуть дальше.

#### Предзагрузка уже полученных записей

Мы также можем предзагрузить связанные схемы для записей, уже полученных из базы.


```elixir
 movie = Repo.get(Movie, 1)
```

```elixir
 movie = Repo.preload(movie, :actors)
```

Теперь можно получить актёров фильма:


```elixir
 movie.actors
```

### Использование операции соединения

Функция `Ecto.Query.join/5` позволяет создавать запросы с использованием SQL-оператора `JOIN`.


```elixir
 alias Friends.Character
```

```elixir
 query = from m in Movie,
```

```elixir
 Repo.all(query)
```

Выражение `on` также может быть в виде ключевого списка:


```elixir
from m in Movie,
  join: c in Character,
  on: [id: c.movie_id], # ключевой список
  where: c.name == "Wade Watts",
  select: {m.title, c.name}
```

В примере выше мы выполняем соединение с Ecto-схемой — `m in Movie`. Но мы также можем соединять с Ecto-запросом. Предположим, что в нашей таблице с фильмами есть столбец `stars`, где мы храним среднюю оценку фильма в "звёздах" — от одной до пяти.


```elixir
movies = from m in Movie, where: [stars: 5]
from c in Character,
  join: ^movies,
  on: [id: c.movie_id], # ключевой список
  where: c.name == "Wade Watts",
  select: {m.title, c.name}
```

Язык запросов Ecto — мощный инструмент, обладающий всем необходимым для построения даже самых сложных запросов к базам данных. В этом уроке мы познакомились с базовыми элементами, необходимыми для конструирования запросов.
