# Concurrencia

## Procesos

Los procesos en la Erlang VM (BEAM) son ligeros y se ejecutan usando todos los CPUs. Pese a que pueden parecer hilos nativos, son más simples y no es raro tener miles de procesos concurrentes en una aplicación de Elixir.

La manera más fácil de crear un nuevo proceso es `spawn`, el cual recibe una función anónima o una función con nombre. Cuando creamos un nuevo proceso se devuelve un _Identificador de Proceso_ o PID, para identificarlo de manera única dentro de nuestra aplicación.

Para comenzar, crearemos un módulo y definiremos una función que queramos ejecutar:


```elixir
 Example.add(2, 3)
```

Para evaluar la función de manera asíncrona usamos `spawn/3`:


```elixir
 spawn(Example, :add, [2, 3])
```

### Paso de mensajes

Para comunicarse, los procesos se basan en paso de mensajes. Hay dos principales componentes para esto: `send/2` y `receive`. La función `send/2` nos permite enviar mensajes a PID's. Para escuchar utilizamos `receive` para coincidir mensajes. Si no se encuentra una coincidencia, la ejecución continúa ininterrumpida.


```elixir
 pid = spawn(Example, :listen, [])
```

```elixir
 send pid, {:ok, "hello"}
```

```elixir
 send pid, :ok
```

### Enlace de procesos

Un problema con `spawn` es saber cuando un proceso falla. Para ello necesitamos enlazar nuestros procesos usando `spawn_link`. Dos procesos enlazados recibirán notificaciones de salida uno del otro:


```elixir
 spawn(Example, :explode, [])
```

```elixir
 spawn_link(Example, :explode, [])
```

A veces no queremos que nuestro proceso enlazado termine el proceso actual. Para ello necesitamos atrapar las salidas. Cuando atrapamos las salidas se recibirán como una tupla en un mensaje: `{:EXIT, from_pid, reason}`.


```elixir
 Example.run
```

### Monitoreo de procesos

¿Qué se puede hacer si no queremos enlazar dos procesos pero aún así mantenerlos informados? Para ello podemos usar monitoreo de procesos con `spawn_monitor`. Cuando monitoreamos un proceso obtenemos un mensaje si el procesos falla sin terminar nuestro proceso actual y sin necesidad de atrapar las salidas de manera explícita.


```elixir
 Example.run
```

## Agentes

Los agentes (Agents) son una abstracción de procesos de fondo que mantienen un estado. Podemos accesarlos de otros procesos dentro de nuestra aplicación y nodo. El estado de nuestro agente es el valor de retorno de nuestra función.


```elixir
 {:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
```

```elixir
 Agent.update(agent, fn (state) -> state ++ [4, 5] end)
```

```elixir
 Agent.get(agent, &(&1))
```

Cuando nombramos un agente lo podemos referenciar por nombre en lugar de su PID:


```elixir
 Agent.start_link(fn -> [1, 2, 3] end, name: Numbers)
```

```elixir
 Agent.get(Numbers, &(&1))
```

## Tareas

Las tareas (Tasks) proveen una manera de ejecutar una función en el fondo y obtener su valor de retorno después. Esto puede ser particularmente útil cuando se manejan operaciones costosas sin bloquear la ejecución de la aplicación.


```elixir
 task = Task.async(Example, :double, [2000])
```

```elixir
 Task.await(task)
```
