# Estructuras de control

## if y unless

Es probable que hayas visto `if/2` antes, y si has utilizado Ruby estás familiarizado con `unless/2`. En Elixir ambos funcionan de la misma forma pero están definidos como macros, no son construcciones propias del lenguaje; puedes encontrar su implementación en el [módulo Kernel](https://hexdocs.pm/elixir/Kernel.html).


Debería tenerse en cuenta que en Elixir, los únicos valores falsos son `nil` y el booleano `false`.


```elixir
 if String.valid?("Hello") do
```

```elixir
 if "a string value" do
```

Usar `unless/2` es como `if/2` solo que trabaja en forma inversa:


```elixir
 unless is_integer("hello") do
```

## case

Si es necesario buscar una coincidencia en múltiples patrones podemos usar `case`:


```elixir
 case {:ok, "Hello World"} do
```

La variable `_` es una inclusión importante en la declaración `case`. Sin esto, cuando no se encuentre una coincidencia, se lanzará un error:


```elixir
 case :even do
```

```elixir
 case :even do
```

Considera `_` como el `else` que coincidirá con "todo lo demás".
Ya que `case` se basa en la coincidencia de patrones, se aplican las mismas reglas y restricciones. Si intentas coincidir con variables existentes debes usar el operador pin `^`:


```elixir
 pie = 3.14
```

```elixir
 case "cherry pie" do
```

Otra característica interesante de `case` es que soporta cláusulas de guardia:

_Este ejemplo proviene directamente de la guía oficial de Elixir [Getting Started](http://elixir-lang.org/getting-started/case-cond-and-if.html#case)._


```elixir
 case {1, 2, 3} do
```

Revisa la documentación oficial para [Expresiones permitidas en cláusulas de guardia](https://hexdocs.pm/elixir/guards.html#list-of-allowed-expressions).


## cond

Cuando necesitamos coincidencias con condiciones, y no valores, podemos cambiar a `cond`; esto es parecido a `else if` o `elsif` en otros lenguajes:

_Este ejemplo proviene directamente de la guía oficial de Elixir [Getting Started](http://elixir-lang.org/getting-started/case-cond-and-if.html#cond)._


```elixir
 cond do
```

Como `case`, `cond` lanzará un error si no hay una coincidencia. Para manejar esto, podemos definir una condición cuyo valor es `true`:


```elixir
 cond do
```

## with

La forma especial `with/1` es útil cuando se pueda usar un `case/2` anidado o en situaciones que no puedan ser encadenadas limpiamente. La expresión `with/1` está compuesta de palabras clave, generadores y, finalmente una expresión.

Hablaremos más de los generadores en la [lección de completado de listas](/es/lessons/basics/comprehensions), pero por ahora lo que necesitamos saber es que usan [coincidencia de patrones](/es/lessons/basics/pattern_matching) para comparar el lado derecho del `<-` con el izquierdo.

Empezaremos con un ejemplo simple de `with/1` y después veremos algo más:


```elixir
 user = %{first: "Sean", last: "Callan"}
```

```elixir
 with {:ok, first} <- Map.fetch(user, :first),
```

En caso de que una expresión falle en coincidir, el valor que no coincida será devuelto:


```elixir
 user = %{first: "doomspork"}
```

```elixir
 with {:ok, first} <- Map.fetch(user, :first),
```

Ahora veamos un ejemplo más grande sin `with/1` y después veamos como lo podemos refactorizar:


```elixir
case Repo.insert(changeset) do
  {:ok, user} ->
    case Guardian.encode_and_sign(user, :token, claims) do
      {:ok, token, full_claims} ->
        important_stuff(token, full_claims)

      error ->
        error
    end

  error ->
    error
end
```

Cuando introducimos `with/1` terminamos con código que es más fácil de entender y es más corto:


```elixir
with {:ok, user} <- Repo.insert(changeset),
     {:ok, token, full_claims} <- Guardian.encode_and_sign(user, :token, claims) do
  important_stuff(token, full_claims)
end
```

A partir Elixir 1.3 las sentencias `with/1` soportan else:


```elixir
import Integer

m = %{a: 1, c: 3}

a =
  with {:ok, number} <- Map.fetch(m, :a),
    true <- is_even(number) do
      IO.puts "#{number} divided by 2 is #{div(number, 2)}"
      :even
  else
    :error ->
      IO.puts("We don't have this item in map")
      :error

    _ ->
      IO.puts("It is odd")
      :odd
  end
```
Esto ayuda a manejar errores dándonos coincidencia de patrones parecida a la del `case`. El valor pasado es el de la primera expresión que no coincidió con el valor esperado.
