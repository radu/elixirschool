# Básico

## Preparar el entorno

### Instalar Elixir

Las instrucciones de instalación para cada sistema operativo pueden ser encontradas en [Elixir-lang.org](http://elixir-lang.org) en la guía [Installing Elixir](http://elixir-lang.org/install.html)(en inglés).

Después de que Elixir haya sido instalado, puedes confirmar la versión instalada fácilmente.

    % elixir -v
    Erlang/OTP {{ site.erlang.OTP }} [erts-{{ site.erlang.erts }}] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

    Elixir {{ site.elixir.version }}

### Probando el Modo Interactivo

Elixir viene con IEx, una consola interactiva, que nos permite evaluar expresiones Elixir al vuelo.

Para empezar, ejecutamos `iex`:

	Erlang/OTP {{ site.erlang.OTP }} [erts-{{ site.erlang.erts }}] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

	Interactive Elixir ({{ site.elixir.version }}) - press Ctrl+C to exit (type h() ENTER for help)
	iex>

Nota: En la PowerShell de Windows, necesitas teclear `iex.bat`.

Avancemos y hagamos una prueba escribiendo unas cuantas expresiones sencillas:


```elixir
 2+3
```

```elixir
 2+3 == 5
```

```elixir
 String.length("The quick brown fox jumps over the lazy dog")
```

No te preocupes si no entiendes cada expresión todavía, pero esperamos que puedas captar la idea.

## Tipos Básicos

### Enteros


```elixir
 255
```

El soporte para números binarios, octales y hexadecimales también viene incluido:


```elixir
 0b0110
```

```elixir
 0o644
```

```elixir
 0x1F
```

### Coma flotante

En Elixir, los números con coma flotante requieren un decimal después de al menos un dígito; estos tienen una precisión de 64 bits y soportan `e` para números exponenciales.


```elixir
 3.14
```

```elixir
 .14
```

```elixir
 1.0e-10
```

### Booleanos

Elixir soporta `true` y `false` como booleanos; todo valor es verdadero a excepción de `false` y `nil`:


```elixir
 true
```

```elixir
 false
```

### Átomos

Un átomo es una constante cuyo nombre es su valor.
Si estás familiarizado con Ruby estos son equivalentes a los Símbolos:


```elixir
 :foo
```

```elixir
 :foo == :bar
```

Los booleanos `true` y `false` son también los átomos `:true` y `:false` respectivamente.


```elixir
 is_atom(true)
```

```elixir
 is_boolean(:true)
```

```elixir
 :true === true
```

Los nombres de módulos en Elixir tambien son átomos. `MyApp.MyModule` es un átomo válido, incluso si el módulo no ha sido declarado aún.


```elixir
 is_atom(MyApp.MyModule)
```

Los átomos también son usados para hacer referencia a módulos de las librerias de Erlang, incluyendo las nativas.


```elixir
 :crypto.strong_rand_bytes 3
```

### Cadenas

Las cadenas en Elixir están codificadas en UTF-8 y están encerradas en comillas dobles:


```elixir
 "Hello"
```

```elixir
 "dziękuję"
```

Las cadenas soportan saltos de línea y secuencias de escape:


```elixir
 "foo
```

```elixir
 "foo\nbar"
```

Elixir también incluye tipos de datos más complejos.
Aprenderemos más sobre ellos cuando veamos [colecciones](/es/lessons/basics/collections) y [funciones](/es/lessons/basics/functions).

## Operaciones Básicas

### Aritmética

Elixir soporta los operadores básicos `+`, `-`, `*`, y `/` como era de esperar.
Es importante resaltar que `/` siempre devolverá un número con coma flotante:


```elixir
 2 + 2
```

```elixir
 2 - 1
```

```elixir
 2 * 5
```

```elixir
 10 / 5
```

Si necesitas una división entera o el resto de una división (el módulo), Elixir viene con dos funciones útiles para para lograr esto:


```elixir
 div(10, 5)
```

```elixir
 rem(10, 3)
```

### Booleanas

Elixir provee los operadores booleanos: `||`, `&&`, y `!`, que soportan cualquier tipo de dato:


```elixir
 -20 || true
```

```elixir
 false || 42
```

```elixir
 42 && true
```

```elixir
 42 && nil
```

```elixir
 !42
```

```elixir
 !false
```

Hay tres operadores adicionales cuyo primer argumento _tiene_ que ser un booleano (`true` y `false`):


```elixir
 true and 42
```

```elixir
 false or true
```

```elixir
 not false
```

```elixir
 42 and true
```

```elixir
 not 42
```

Nota: Los operadores de Elixir `and` y `or` en realidad mapean a `andalso` y `orelse` de Erlang.

### Comparación

Elixir viene con todos los operadores de comparación a los que estamos acostumbrados: `==`, `!=`, `===`, `!==`, `<=`, `>=`, `<` y `>`.


```elixir
 1 > 2
```

```elixir
 1 != 2
```

```elixir
 2 == 2
```

```elixir
 2 <= 3
```

Para comparación estricta de enteros y flotantes usamos `===`:


```elixir
 2 == 2.0
```

```elixir
 2 === 2.0
```

Una característica importante de Elixir es que cualquier par de tipos se pueden comparar, esto es útil particularmente en ordenación. No necesitamos memorizar el orden pero es importante ser consciente de este:


```elixir
number < atom < reference < function < port < pid < tuple < map < list < bitstring
```

Esto puede conducir a algunas interesantes y válidas comparaciones que no puedes encontrar en otros lenguajes:


```elixir
 :hello > 999
```

```elixir
 {:hello, :world} > [1, 2, 3]
```

### Interpolación de cadenas

Si has usado Ruby, la interpolación de cadenas en Elixir te parecerá muy familiar:


```elixir
 name = "Sean"
```

```elixir
 "Hello #{name}"
```

### Concatenación de cadenas

La concatenación de cadenas usa el operador `<>`:


```elixir
 name = "Sean"
```

```elixir
 "Hello " <> name
```
