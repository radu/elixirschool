# Operador Pipe

## Introducción

La programación puede ser desordenada.
De hecho tan desordenada que las llamadas de función pueden estar tan contenidas que sean difícil de entender.

Por ejemplo, toma en consideración las siguientes funciones anidadas:


```elixir
foo(bar(baz(nueva_function(otra_function()))))
```

Aquí, pasamos el valor de `otra_function/1` a `nueva_function/1`, y de `nueva_function/1` a `baz/1`, `baz/1` a `bar/1`, y finalmente el resultado de `bar/1` a `foo/1`.
Elixir adopta un enfoque pragmático a este caos sintáctico al darnos el operador pipe.
El operador pipe que luce así `|>` *toma el resultado de una expresión, y se lo pasa a la siguiente*.
Vamos a echar otro vistazo al código anterior reescrito con el operador pipe.


```elixir
otra_function() |> nueva_function() |> baz() |> bar() |> foo()
```

El operador lleva el resultado de la izquierda, y lo pasa a la derecha.

## Ejemplos

Para este grupo de ejemplos, usaremos el módulo String de elixir.

- Separar Cadenas (Tokenize String)


```elixir
 "Elixir language" |> String.split()
```

- Mayúsculas a todos los caracteres (Uppercase all the tokens)


```elixir
 "Elixir language" |> String.upcase() |> String.split()
```

- Comparar terminación de una cadena (Check ending)


```elixir
 "elixir" |> String.ends_with?("ixir")
```

## Buenas Prácticas

Si la aridad de una función es mayor a 1, asegurate de usar paréntesis.
Esto no importa mucho en Elixir, pero es importante para otros programadores que pueden malinterpretar tu código.
Sin embargo, este si importa para el operador pipe.
Por ejemplo, si en el tercer ejemplo eliminamos los paréntesis de `String.ends_with?`, tendríamos la siguiente advertencia.


```elixir
 "elixir" |> String.ends_with? "ixir"
```
