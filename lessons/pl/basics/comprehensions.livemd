# Składanie kolekcji

## Podstawy

Najczęściej składanie list używane jest do tworzenia bardziej zwięzłego kodu do iterowania w `Enum` oraz `Stream`.
Przyjrzyjmy się prostemu przykładowi składania kolekcji, a następnie omówmy jego elementy:


```elixir
 list = [1, 2, 3, 4, 5]
```

```elixir
 for x <- list, do: x*x
```

Pierwsze co możemy zauważyć, to użycie słowa kluczowego `for` i generatora.
Czym jest generator?
Generatorem nazywamy wyrażenie `x <- [1, 2, 3, 4]` znajdujące się w liście składanej.
Odpowiada ono za generowanie kolejnych wartości.

Oczywiście składanie można stosować nie tylko do list, ale do wszystkich danych typu wyliczeniowego (ang. _enumerables_).


```elixir
 for {_key, val} <- [one: 1, two: 2, three: 3], do: val
```

```elixir
 for {k, v} <- %{"a" => "A", "b" => "B"}, do: {k, v}
```

```elixir
 for <<c <- "hello">>, do: <<c>>
```

Jak zapewne zauważyłeś, generatory opierają się o dopasowanie wzorców, by przypisać dane do zmiennej po lewej stronie.
Jeżeli jakiś element nie zostanie dopasowany, to jest po prostu ignorowany:


```elixir
 for {:ok, val} <- [ok: "Hello", error: "Unknown", ok: "World"], do: val
```

Możliwe jest użycie wielu generatorów naraz, co może trochę przypominać zagnieżdżone pętle:


```elixir
 list = [1, 2, 3, 4]
```

```elixir
 for n <- list, times <- 1..n do
```

By lepiej zilustrować to zachowanie, użyjmy `IO.puts`, by wyświetlić wartości z dwóch generatorów:


```elixir
 for n <- list, times <- 1..n, do: IO.puts "#{n} - #{times}"
```

Składanie list to tzw. lukier składniowy i powinno być stosowane tylko wtedy, kiedy faktycznie jest potrzebne.

## Filtry

O filtrach możemy myśleć jak o strażnikach dla składania list.
Gdy filtr zwraca wartość `false` lub `nil`, wartość ta jest wyłączana z ostatecznej listy.
Przeiterujmy po liście, biorąc pod uwagę jedynie liczby parzyste.
By sprawdzić parzystość liczby, użyjemy funkcji `is_even/1` z modułu Integer:


```elixir
 for x <- 1..10, is_even(x), do: x
```

Filtry, podobnie jak generatory, możemy łączyć.
Rozszerzmy nasz zakres liczb, a następnie przefiltrujmy go tak, by znaleźć liczby, które są jednocześnie parzyste i podzielne przez 3:


```elixir
 for x <- 1..100,
```

## Użycie :into

Co jeżeli chcemy otrzymać coś innego niż listę?
Po to mamy opcję `:into`!
Ogólna zasada jest taka, że `:into` akceptuje jako argument dowolną strukturę implementującą protokół `Collectable`.

Użyjmy`:into`, by stworzyć mapę z listy asocjacyjnej:


```elixir
 for {k, v} <- [one: 1, two: 2, three: 3], into: %{}, do: {k, v}
```

Jako że binarne ciągi znaków są kolekcjami, możemy użyć składania w połączeniu z `:into` by stworzyć ciąg znaków:


```elixir
 for c <- [72, 101, 108, 108, 111], into: "", do: <<c>>
```

I to wszystko!
Składanie list jest mechanizmem pozwalającym na tworzenie zwięzłego kodu do obsługi kolekcji.
