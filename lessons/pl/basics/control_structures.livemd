# Struktury sterujące

## if i unless

Zapewne spotkałeś się już z `if/2` w innych językach, a jeżeli znasz język Ruby, to również `unless/2` zapewne nie będzie Ci obce.
W Elixirze instrukcje te działają w podobny sposób, ale nie są elementami języka, a makrami. Ich implementacje możesz znaleźć w dokumentacji [modułu jądra](https://hexdocs.pm/elixir/Kernel.html).

Przypomnijmy, że w Elixirze jedynymi wartościami traktowanymi jako _fałsz_ są `nil` i wartość logiczna `false`.


```elixir
 if String.valid?("Hello") do
```

```elixir
 if "a string value" do
```

Użycie `unless/2` jest podobne do `if/2`, tylko że warunek działa na odwrót:


```elixir
 unless is_integer("hello") do
```

## case

Jeżeli chcemy sprawdzić wiele różnych wzorców, to możemy użyć `case/2`:


```elixir
 case {:ok, "Hello World"} do
```

Zmienna `_` jest istotnym elementem wyrażenia `case/2`. Bez niej, jeżeli nie będzie istnieć dopasowanie, program zwróci błąd:


```elixir
 case :even do
```

```elixir
 case :even do
```

Konstrukcję `_` możesz rozumieć jako `else` – dopasowuje bowiem „wszystko inne”.

Jako że `case/2` wykorzystuje dopasowanie wzorców, wszystkie zasady tam obowiązujące są zachowane.
Jeżeli chcesz dopasować istniejącą zmienną, musisz użyć operatora przypięcia `^`:


```elixir
 pie = 3.14 
```

```elixir
 case "cherry pie" do
```

Kolejną właściwością `case` jest wsparcie dla wyrażeń strażników:

_Ten przykład pochodzi z oficjalnego przewodnika po języku Elixir [Getting Started](http://elixir-lang.org/getting-started/case-cond-and-if.html#case)._


```elixir
 case {1, 2, 3} do
```

Więcej szczegółów znajdziesz w dokumentacji w języku angielskim, w module [Expressions allowed in guard clauses](https://hexdocs.pm/elixir/guards.html#list-of-allowed-expressions).

## cond

Jeżeli chcemy sprawdzić warunki niebędące wartościami, możemy użyć `cond/1`; wyrażenie to odpowiada konstrukcjom `else if` czy `elsif` z innych języków:

_Ten przykład pochodzi z oficjalnego przewodnika po języku Elixir [Getting Started](http://elixir-lang.org/getting-started/case-cond-and-if.html#cond)._


```elixir
 cond do
```

Podobnie jak `case`, `cond` zwróci błąd, jeżeli żadne z wyrażeń nie będzie spełnione. By obsłużyć taką sytuację, możemy jako warunek podać `true`:


```elixir
 cond do
```

## with

Konstrukcji `with/1` możemy użyć zamiast wielu zagnieżdżonych wyrażeń `case/2` lub w sytuacjach, gdy nie mogą być one powiązane w jednoznaczny sposób. Wyrażenie `with/1` składa się ze słowa kluczowego, generatora i wyrażenia.

Zajmiemy się jeszcze generatorami przy okazji omawiania [list składanych](/pl/lessons/basics/comprehensions), ale na chwilę obecną jedyne, co musimy wiedzieć, to że używają [dopasowania wzorców](/pl/lessons/basics/pattern_matching), by połączyć elementy po prawej stronie `<-` z tymi po lewej.

Zacznijmy od prostego wyrażenia `with/1`:


```elixir
 user = %{first: "Sean", last: "Callan"}
```

```elixir
 with {:ok, first} <- Map.fetch(user, :first),
```

W przypadku, kiedy żadne z wyrażeń nie zostanie dopasowane, zostanie zwrócona niepasująca wartość:


```elixir
 user = %{first: "doomspork"}
```

```elixir
 with {:ok, first} <- Map.fetch(user, :first),
```

Teraz przyjrzyjmy się większemu przykładowi bez `with/1`, a następnie zrefaktoryzujmy go:


```elixir
case Repo.insert(changeset) do
  {:ok, user} ->
    case Guardian.encode_and_sign(user, :token, claims) do
      {:ok, jwt, full_claims} ->
        important_stuff(jwt, full_claims)

      error ->
        error
    end

  error ->
    error
end
```

Dzięki wprowadzeniu `with/1` nasz końcowy kod jest krótszy i łatwiejszy do zrozumienia:


```elixir
with {:ok, user} <- Repo.insert(changeset),
     {:ok, token, full_claims} <- Guardian.encode_and_sign(user, :token, claims) do
  important_stuff(token, full_claims)
end
```

Elixir od wersji 1.3 pozwala też na użycie `else` w wyrażeniach `with/1`:


```elixir
import Integer

m = %{a: 1, c: 3}

a =
  with {:ok, number} <- Map.fetch(m, :a),
    true <- is_even(number) do
      IO.puts "#{number} divided by 2 is #{div(number, 2)}"
      :even
  else
    :error ->
      IO.puts("We don't have this item in map")
      :error

    _ ->
      IO.puts("It is odd")
      :odd
  end
```

Pozwala to na łatwiejszą obsługę błędów, która jest podobna do wyrażenia `case`.
Przekazywana wartość to pierwsze niedopasowane wyrażenie.
