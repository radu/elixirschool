# Kolekcje

## Listy

Listy to proste zbiory nieunikalnych wartości różnych typów:


```elixir
 [3.14, :pie, "Apple"]
```

Elixir implementuje listę jako listę wiązaną.
Oznacza to, że obliczenie rozmiaru listy ma złożoność `O(n)`.
Z tego powodu dodawanie elementów na początku jest zwykle szybsze niż dołączanie na koniec listy:


```elixir
 list = [3.14, :pie, "Apple"]
```

```elixir
 ["π" | list]
```

```elixir
 list ++ ["Cherry"]
```

### Łączenie list

Do łączenia list służy operator `++/2`:


```elixir
 [1, 2] ++ [3, 4, 1]
```

Na marginesie należy wspomnieć o formacie nazwy użytym powyżej (`++/2`).
W Elixirze, jak i w Erlangu, na którym bazuje Elixir, każda nazwa funkcji lub operatora składa się z dwóch elementów – z nazwy, tu `++` i liczby argumentów (arności, argumentowości).
Arność wraz z nazwą funkcji zapisaną z użyciem slasha jest kluczową kwestią, jeżeli chcemy mówić o kodzie Elixira (jak i Erlanga).
Będziemy jeszcze o tym mówić, a na chwilę obecną ułatwi nam to zrozumienie używanej notacji.   

### Usuwanie elementów

Usuwanie elementów wykonuje operator `--/2`; operacja jest bezpieczna, jeżeli chcemy usunąć nieistniejący element:


```elixir
 ["foo", :bar, 42] -- [42, "bar"]
```

Jeżeli na liście występują duplikaty, to zostanie usunięty pierwszy z nich:


```elixir
 [1,2,2,3,2,3] -- [1,2,3,2]
```

**Uwaga:** Operacja używa [dokładnego porównania](/pl/lessons/basics/basics#comparison) przy wyszukiwaniu wartości.


```elixir
 [2] -- [2.0]
```

```elixir
 [2.0] -- [2.0]
```

### Głowa i ogon listy

Pracując z listami, będziemy często używać pojęć głowa i ogon.
Głowa jest to pierwszy element listy, a ogon to pozostałe elementy.
Elixir ma dwie pomocne metody, `hd` i `tl`, które pomagają w pracy z tymi elementami:


```elixir
 hd [3.14, :pie, "Apple"]
```

```elixir
 tl [3.14, :pie, "Apple"]
```

Oprócz wyżej wymienionych funkcji, możesz użyć [dopasowywania wzorców](/pl/lessons/basics/pattern_matching) i operatora `|`, aby podzielić listę na początek i koniec.
Dowiemy się więcej o tym schemacie w kolejnych lekcjach:


```elixir
 [head | tail] = [3.14, :pie, "Apple"]
```

```elixir
 head
```

```elixir
 tail
```

_Uwaga_: znak `|` w tym przypadku oznacza operator _cons_ (od ang. _construct_) – tworzenia, a nie operator _pipe_ – łączenia.  

## Krotki

Krotki są podobne do list, ale zajmują ciągły obszar pamięci.
Powoduje to, że odczyt jest bardzo szybki, lecz modyfikacja kosztowna; zmiana wartości oznacza stworzenie nowej krotki i skopiowanie elementów starej.
Krotki definiujemy za pomocą klamer:


```elixir
 {3.14, :pie, "Apple"}
```

Typowym zastosowaniem krotek jest zwracanie dodatkowych informacji z funkcji.
Jest to bardzo przydatne, przez co przyjrzymy się temu bliżej przy omawianiu mechanizmu [dopasowywania wzorców](/pl/lessons/basics/pattern_matching):


```elixir
 File.read("path/to/existing/file")
```

```elixir
 File.read("path/to/unknown/file")
```

## Listy asocjacyjne

Listy asocjacyjne i mapy są to dwa rodzaje kolekcji asocjacyjnych w Elixirze.
W Elixirze lista asocjacyjna jest to specjalna lista krotek, których pierwszym elementem jest atom; zachowują się one jak zwykłe listy:


```elixir
 [foo: "bar", hello: "world"]
```

```elixir
 [{:foo, "bar"}, {:hello, "world"}]
```

Trzy cechy list asocjacyjnych podkreślają ich znaczenie:

+ Klucze są atomami.
+ Klucze zachowują kolejność.
+ Klucze mogą nie być unikalne.

Z tej właśnie przyczyny listy asocjacyjne są zazwyczaj używane do przekazywania opcji do funkcji.

## Mapy

W Elixirze mapy to dobrze znane kontenery przechowujące pary klucz-wartość.
W przeciwieństwie do list asocjacyjnych pozwalają by klucz był dowolnego typu i nie muszą zachowywać kolejności.
Mapę definiujemy za pomocą `%{}`:


```elixir
 map = %{:foo => "bar", "hello" => :world}
```

```elixir
 map[:foo]
```

```elixir
 map["hello"]
```

Od wersji 1.2 Elixira zmienne mogą być użyte jako klucz:


```elixir
 key = "hello"
```

```elixir
 %{key => "world"}
```

Jeżeli dodamy do mapy duplikat, to zastąpi on już istniejącą wartość:


```elixir
 %{:foo => "bar", :foo => "hello world"}
```

Na powyższym przykładzie zastosowaliśmy specjalną konwencję zapisu dostępną tylko wtedy gdy wszystkie klucze są atomami:


```elixir
 %{foo: "bar", hello: "world"}
```

```elixir
 %{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}
```

Mapy posiadają też własną składnię służącą do dostępu i aktualizacji kluczy:


```elixir
 map = %{foo: "bar", hello: "world"}
```

```elixir
 %{map | foo: "baz"}
```

```elixir
 map.hello
```

**Uwaga:** ta składnia działa tylko w przypadku aktualizacji klucza, który już istnieje w mapie!
Jeśli klucz nie istnieje, zostanie zgłoszony błąd `KeyError`.
Aby utworzyć nowy klucz, zamiast tego użyj [`Map.put/3`](https://hexdocs.pm/elixir/Map.html#put/3).


```elixir
 map = %{hello: "world"}
```

```elixir
 %{map | foo: "baz"}
```

```elixir
 Map.put(map, :foo, "baz")
```
