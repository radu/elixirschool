# Współbieżność

## Procesy

Maszyna wirtualna Erlanga używa procesów lekkich, które mogą działać na wszystkich dostępnych dla niej procesorach.
Choć są one podobne do natywnych, systemowych wątków, to jednak są prostsze i nie jest niczym niezwykłym, gdy w aplikacji napisanej w Elixirze jednocześnie działa kilka tysięcy procesów.

Najprostszą metodą na utworzenie nowego procesu jest wywołanie `spawn`, która jako argument przyjmuje funkcję, nazwaną lub anonimową.
Kiedy utworzy nowy proces zwróci _Identyfikator procesu_, czyli PID, który w sposób unikalny identyfikuje proces w naszej aplikacji.

Zacznijmy od stworzenia nowego modułu i zdefiniowania w nim funkcji, którą będziemy uruchamiać:


```elixir
 Example.add(2, 3)
```

By wywołać ją asynchronicznie wywołajmy `spawn/3`:


```elixir
 spawn(Example, :add, [2, 3])
```

### Przekazywanie komunikatów

Komunikacja pomiędzy procesami bazuje na wymianie komunikatów.
Istnieją dwa główne elementy tego mechanizmu: `send/2` i `receive`.
Funkcja `send/2` pozwalana na wysłanie komunikatu pod wskazany PID.
Przychodzących komunikatów nasłuchujemy za pomocą `receive` i dopasowujemy je do wzorców.
Jeżeli komunikat nie zostanie dopasowany, to proces zignoruje go i będzie kontynuować działanie, jak gdyby nic się nie stało.


```elixir
 pid = spawn(Example, :listen, [])
```

```elixir
 send pid, {:ok, "hello"}
```

```elixir
 send pid, :ok
```

Warto zauważyć, że funkcja `listen/0` jest rekurencyjna.
Dzięki temu może ona obsługiwać kolejno nadchodzące wiadomości.
Bez tego mechanizmu proces zakończyłby działanie po obsłużeniu pierwszej wiadomości.

### Łączenie procesów

Problem z funkcją `spawn` polega na tym, że nie wiemy, kiedy proces ulegnie awarii.
Dlatego też potrzebujemy procesów połączonych, które tworzy się z użyciem `spawn_link`.
Dwa połączone procesy będą nawzajem otrzymywać komunikaty o swoim zakończeniu:


```elixir
 spawn(Example, :explode, [])
```

```elixir
 spawn_link(Example, :explode, [])
```

Czasami nie chcemy by awaria jednego procesu spowodowała zamknięcie połączonego z nim innego procesu.
Dlatego też musimy przechwycić informacje o zamknięciu korzystając z `Process.flag/2`.
Wykorzystana zostaje funkcja [process_flag/2](http://erlang.org/doc/man/erlang.html#process_flag-2) dla flagi `trap_exit`.
Podczas przechwytywania wyjść (`trap_exit` jest ustawione na `true`), sygnały wyjścia będą odbierane jako wiadomość w postaci krotki: `{:EXIT, from_pid, reason}`.


```elixir
 Example.run
```

### Monitoring

A co, jeżeli nie chcemy łączyć procesów, ale chcemy nadal być informowani o awariach?
Do tego służy mechanizm monitoringu `spawn_monitor`.
Gdy monitorujemy inny proces z naszego procesu, to gdy otrzymamy wiadomość o jego awarii, nasz proces nie ulegnie awarii ani też nie będziemy musieli jawnie obsłużyć sygnału zamknięcia.


```elixir
 Example.run
```

## Agenci

Agenci są pewnego rodzaju abstrakcją nad procesami służącą do zarządzania ich stanem w tle.
Możemy się do nich odwołać z poziomu innego procesu aplikacji albo innego węzła.
Aktualny stan agenta jest równy wartości zwracanej przez naszą funkcję:


```elixir
 {:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
```

```elixir
 Agent.update(agent, fn (state) -> state ++ [4, 5] end)
```

```elixir
 Agent.get(agent, &(&1))
```

Do nazwanych agentów możemy odwołać się przez nazwę zamiast przez PID:


```elixir
 Agent.start_link(fn -> [1, 2, 3] end, name: Numbers)
```

```elixir
 Agent.get(Numbers, &(&1))
```

## Zadania

Zadania pozwalają na wywołanie funkcji w tle i otrzymanie wyniku w późniejszym terminie.
Jest to przydatne szczególnie wtedy, gdy funkcja wykonuje jakieś długotrwałe obliczenia albo jest operacją blokującą.
Można wtedy wywołać ją bez blokowania całej aplikacji.


```elixir
 task = Task.async(Example, :double, [2000])
```

```elixir
 Task.await(task)
```
