# 並行性

## プロセス

Erlang VM (BEAM)内のプロセスは軽量で、全てのCPU間で実行されます。
ネイティブスレッドのように見えますがそれより単純ですし、Elixirアプリケーション内に数千もの並行プロセスを持つことは珍しくありません。

新しいプロセスを作る最も簡単な方法は、匿名/名前付き関数を引数に取る `spawn` です。
新しいプロセスが作られると、 _プロセス識別子_ 別名PIDが返ります。これはアプリケーション内部でプロセスを一意に識別するものです。

手始めに、モジュールを作り実行したい関数を定義します:


```elixir
 Example.add(2, 3)
```

この関数を非同期的に評価するには、 `spawn/3` を用います:


```elixir
 spawn(Example, :add, [2, 3])
```

### メッセージパッシング

相互通信をするのに、プロセスはメッセージパッシングを頼ります。
これには2つの主な部品、 `send/2` と `receive` があります。
`send/2` 関数を使うとメッセージをPID宛に送ることができます。
受信するには `receive` を使ってメッセージをマッチし、マッチするものが見つからない場合は中断されずに実行中のままとなります。


```elixir
 pid = spawn(Example, :listen, [])
```

```elixir
 send pid, {:ok, "hello"}
```

```elixir
 send pid, :ok
```

`listen/0` 関数が再帰的であることに気づいたかもしれません。これはプロセスで複数のメッセージを扱うためです。
再帰がないと、プロセスは初めのメッセージを受け取り処理した後に終了するでしょう。

### プロセスのリンク

`spawn` の問題の1つとして知られているのは、プロセスが強制終了した場合です。
これに備えるためには、複数プロセスを `spawn_link` でリンクする必要があります。
二者間でリンクしたプロセスはプロセス終了の通知をお互いに受け取ります(訳注: つまりどちらのプロセスも終了します。):


```elixir
 spawn(Example, :explode, [])
```

```elixir
 spawn_link(Example, :explode, [])
```

リンクしたプロセスに現在のプロセスを強制終了させたくない場合もあるでしょう。
そのためには `Process.flag/2` 使用して終了を捕捉する必要があります。この関数は `trap_exit` フラグのためにErlangの [process_flag/2](http://erlang.org/doc/man/erlang.html#process_flag-2) 関数を使います。終了を捕捉すると(`trap_exit` が `true` になっている)、 `{:EXIT, from_pid, reason}` というタプルのメッセージとして受け取ります。


```elixir
 Example.run
```

### プロセス監視

2つのプロセスをリンクせずに、しかし通知はそのまま維持したいとすると、どうでしょうか。そうした場合には `spawn_monitor` でプロセス監視を用いることができます。
プロセスを監視すると、プロセスが強制終了した際にメッセージを受け取ります。現在のプロセスを強制終了させたり、プロセス終了時に明示的な捕捉をする必要はありません。


```elixir
 Example.run
```

## Agent

Agentは状態を維持するバックグラウンドプロセス周りを抽象化したものです。
アプリケーションやノードの内部で他のプロセスからAgentに接続することができます。
Agentの状態は関数の戻り値に与えられます:


```elixir
 {:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
```

```elixir
 Agent.update(agent, fn (state) -> state ++ [4, 5] end)
```

```elixir
 Agent.get(agent, &(&1))
```

Agentに名前を付けると、PIDの代わりに名前で参照することができます:


```elixir
 Agent.start_link(fn -> [1, 2, 3] end, name: Numbers)
```

```elixir
 Agent.get(Numbers, &(&1))
```

## Task

Taskは関数をバックグラウンドで実行し、後でその戻り値を受け取る方法を提供します。
アプリケーションの動作を妨げることなく、実行コストの高い演算を処理する時に特に役立てることができます。


```elixir
 task = Task.async(Example, :double, [2000])
```

```elixir
 Task.await(task)
```
