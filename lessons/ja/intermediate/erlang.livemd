# Erlangとの相互運用

## 標準ライブラリ

Erlangの豊富な標準ライブラリはアプリケーション内のどのElixirコードからもアクセスすることができます。Erlangモジュールは `:os` や `:timer` のように小文字のアトムで表されます。

`:timer.tc` を用いて、与えられた関数の実行時間を測定してみましょう:


```elixir
 Example.timed(fn (n) -> (n * n) * n end, [100])
```

利用可能なモジュールの一覧は、 [Erlang Reference Manual](http://erlang.org/doc/apps/stdlib/) を参照してください。

## Erlangパッケージ

以前のレッスンでMixと依存関係の管理を扱いましたが、Erlangライブラリを組み込むのも同様の方法で動作します。万が一Erlangライブラリが [Hex](https://hex.pm) に上がっていない(プッシュされていない)場合には、代わりにgitリポジトリを参照することができます:


```elixir
def deps do
  [{:png, github: "yuce/png"}]
end
```

これでErlangライブラリにアクセスできるようになりました:


```elixir
png =
  :png.create(%{:size => {30, 30}, :mode => {:indexed, 8}, :file => file, :palette => palette})
```

## 注目すべき違い

Erlangを用いる方法について理解したので、Erlangとの相互運用に伴って生じる直感的ではない部分についても扱うべきでしょう。

### アトム

ErlangのアトムはElixirのものにとてもよく似ていますが、コロン(`:`)がありません。小文字とアンダースコアで表されます:

Elixir:


```elixir
:example
```

Erlang:

```erlang
example.
```

### 文字列

Elixirの文字列はUTF-8でエンコードされたバイナリを意味しています。Erlangでもstringはダブルクオートを使って表しますが、文字リストのことを指します:

Elixir:


```elixir
 is_list('Example')
```

```elixir
 is_list("Example")
```

```elixir
 is_binary("Example")
```

```elixir
 <<"Example">> === "Example"
```

Erlang:

```erlang
1> is_list('Example').
false
2> is_list("Example").
true
3> is_binary("Example").
false
4> is_binary(<<"Example">>).
true
```

重要なので注記しておくと、古いErlangライブラリではバイナリに対応していないものが多いため、Elixirの文字列は文字リストに変換する必要があります。ありがたいことに、これは `to_charlist/1` 関数を用いて簡単に行うことができます:


```elixir
 :string.words("Hello World")
```

```elixir
 "Hello World" |> to_charlist |> :string.words
```

### 変数

Erlangでは、変数は大文字で始まりバインドし直すことが出来ません。

Elixir:


```elixir
 x = 10
```

```elixir
 x = 20
```

```elixir
 x1 = x + 10
```

Erlang:

```erlang
1> X = 10.
10

2> X = 20.
** exception error: no match of right hand side value 20

3> X1 = X + 10.
20
```

おしまいです！ErlangをElixirアプリケーション内部から活用するのは簡単ですし、利用可能なライブラリの数が事実上倍になります。
