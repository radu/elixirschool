# Συγχρονισμός

## Διεργασίες

Οι διεργασίες στην εικονική μηχανή της Erlang είναι ελαφριές και τρέχουν σε όλους τους επεξεργαστές.
Παρόλο που φαίνονται σαν τοπικά νήματα, είναι πιο απλές και είναι συνηθισμένο να έχουμε χιλιάδες συγχρονισμένες διεργασίες σε μια εφαρμογή Elixir.

Ο πιο απλός τρόπος να δημιουγήσουμε μια νέα διεργασία είναι η `spawn`, η οποία δέχεται είτε μια ανώνυμη ή μια ονομασμένη συνάρτηση.
Όταν δημιουργούμε μια νέα διεργασία επιστρέφει ένα _Προσδιοριστικό Διεργασίας_, ή PID για να την προσδιορίζει μοναδικά στην εφαρμογή μας.

Για να ξεκινήσουμε θα δημιουργήσουμε μια ενότητα και θα ορίσουμε μια συνάρτηση που θα θέλαμε να τρέξουμε:


```elixir
 Example.add(2, 3)
```

Για να τρέξουμε τη συνάρτηση ασύγχρονα θα χρησιμοποιήσουμε την `spawn/3`:


```elixir
 spawn(Example, :add, [2, 3])
```

### Αποστολή Μηνυμάτων

Για να επικοινωνήσουν, οι διεργασίες στηρίζονται στο πέρασμα μηνυμάτων.
Υπάρχουν δύο κύρια συστατικά σε αυτό: οι `send/2` και `receive`.
Η συνάρτηση `send/2` μας επιτρέπει να στέλνουμε μηνύματα σε PID.
Για να τα λαμβάνουμε χρησιμοποιούμε την `receive` για να αντιπαραβάλουμε μηνύματα.
Αν δεν βρεθεί ταίρι η εκτέλεση συνεχίζει απερίσπαστη.


```elixir
 pid = spawn(Example, :listen, [])
```

```elixir
 send pid, {:ok, "hello"}
```

```elixir
 send pid, :ok
```

Μπορεί να παρατηρήσετε ότι η συνάρτηση 'listen/0' είναι αναδρομική, αυτό επιτρέπει στην διεργασία μας να διαχειρίζεται πολλαπλά μηνύματα.
Χωρίς την αναδρομή η διεργασία μας θα τερματιζόταν μετά την διαχείριση του πρώτου μηνύματος.

### Σύνδεση Διεργασιών

Ένα πρόβλημα την `spawn` είναι όταν πρέπει να  ξέρουμε πότε μια διεργασία κρασάρει.
Για αυτό πρέπει να συνδέσουμε τις διεργασίες μας με την χρήση της `spawn_link`.
Δύο συνδεδεμένες διεργασίες θα λάβουν ειδοποιήσεις εξόδου η μία από την άλλη:


```elixir
 spawn(Example, :explode, [])
```

```elixir
 spawn_link(Example, :explode, [])
```

Μερικές φορές δεν θέλουμε τις συνδεδεμένες διεργασίες μας να κρασάρουν την τρέχουσα.
Για αυτό πρέπει να παγιδεύσουμε τις εξόδους.
Όταν παγιδεύουμε τις εξόδους αυτές θα ληφθούν σαν ένα μήνυμα με μορφή τούπλας: `{:EXIT, from_pid, reason}`.


```elixir
 Example.run
```

### Παρακολούθηση Διεργασιών

Τι γίνεται όταν δεν θέλουμε να συνδέσουμε δύο διεργασίες αλλά παρόλα αυτά να ενημερωνόμαστε; Για αυτό μπορούμε να χρησιμοποιήσουμε την παρακολούθηση διεργασίας με την `spawn_monitor`.
Όταν παρακολουθούμε μια διεργασία λαμβάνουμε ένα μήνυμα αν η διεργασία κρασάρει χωρίς να κρασάρει η τρέχουσα διεργασία ή να παγιδεύσουμε τις εξόδους.


```elixir
 Example.run
```

## Πράκτορες

Οι πράκτορες είναι μια αφαίρεση γύρω από την διατήρηση κατάστασης των διεργασιών παρασκηνίου.
Μπορούμε να έχουμε πρόσβαση σε αυτές από άλλες διεργασίες μέσα από την εφαρμογή και τον κόμβο μας.
Η κατάσταση του Πράκτορά μας ορίζεται σαν η τιμή επιστροφής της συνάρτησής μας:


```elixir
 {:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
```

```elixir
 Agent.update(agent, fn (state) -> state ++ [4, 5] end)
```

```elixir
 Agent.get(agent, &(&1))
```

Όταν ονομάζουμε έναν Πράκτορα μπορούμε να αναφερθούμε σε αυτόν αντί στο PID του:


```elixir
 Agent.start_link(fn -> [1, 2, 3] end, name: Numbers)
```

```elixir
 Agent.get(Numbers, &(&1))
```

## Εργασίες

Οι Εργασίες παρέχουν ένα τρόπο να εκτελέσουμε μια συνάρτηση στο παρασκήνιο και να λάβουμε την τιμή επιστροφής της αργότερα.
Μπορούν να είναι ιδιαίτερα χρήσιμες όταν χειρίζονται ακριβές λειτουργίες χωρίς να μπλοκάρουν την εκτέλεση της εφαρμογής.


```elixir
 task = Task.async(Example, :double, [2000])
```

```elixir
 Task.await(task)
```
