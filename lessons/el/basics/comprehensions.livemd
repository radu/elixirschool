# Ανάγνωση Λιστών

## Βασικά

Συχνά οι αναγνώσεις μπορούν να χρησιμοποιηθούν για να παράγουν πιο συνοπτικές εκφράσεις για τις επαναλήψεις `Enum` και `Stream`.  Ας δούμε μια απλή ανάγνωση και μετά ας την αναλύσουμε:


```elixir
 list = [1, 2, 3, 4, 5]
```

```elixir
 for x <- list, do: x*x
```

Το πρώτο πράγμα που παρατηρούμε είναι η χρήση της `for` και ενός παραγωγού.  Τι είναι ο παραγωγός; Οι παραγωγοί είναι οι εκφράσεις `x <- [1, 2, 3, 4]` που βρίσκονται στις αναγνώσεις λιστών, είναι υπεύθυνοι για την παραγωγή της επόμενης τιμής.

Είμαστε τυχεροί που οι αναγνώσεις δεν περιορίζονται στις λίστες, στην πράξη δουλεύουν με όλες τις συλλογές:


```elixir
 for {_key, val} <- [one: 1, two: 2, three: 3], do: val
```

```elixir
 for {k, v} <- %{"α" => "Α", "β" => "Β"}, do: {k, v}
```

```elixir
 for <<c <- "γειά">>, do: <<c>>
```

Όπως πολλά άλλα πράγματα στην Elixir, οι παραγωγοί εξαρτώνται από την αντιπαραβολή προτύπων για να συγκρίνουν την είσοδο που έχει οριστεί στη μεταβλητή στα αριστερά.  Σε περίπτωση που δεν υπάρξει αντιπαραβολή, η τιμή αγνοείται:


```elixir
 for {:ok, val} <- [ok: "Γεια σου", error: "Αγνωστε", ok: "Κόσμε"], do: val
```

Είναι πιθανό να χρησιμοποιήσουμε πολλαπλούς παραγωγούς, όπως περίπου στις ένθετες επαναλήψεις:


```elixir
 list = [1, 2, 3, 4]
```

```elixir
 for n <- list, times <- 1..n do
```

Για να παρουσιάσουμε καλύτερα την επανάληψη που προκύπτει, ας χρησιμοποιήσουμε την `IO.puts` για αν εμφανίσουμε τις δύο παραγόμενες τιμές:


```elixir
 for n <- list, times <- 1..n, do: IO.puts "#{n} - #{times}"
```

Οι αναγνώσεις λιστών είναι συντομογραφίες και θα πρέπει να χρησιμοποιούνται μόνο όταν πρέπει.

## Φίλτρα

Μπορείτε να σκεφτείτε τα φίλτρα σαν ένα είδος προστάτη για αναγνώσεις.  Όταν μια φιλτραρισμένη τιμή επιστρέφει `false` ή `nil`, εξαιρείται από την τελική λίστα.  Ας κάνουμε μια επανάληψη σε ένα έυρος και να ανησυχήσουμε μόνο για τους ζυγούς αριθμούς. Θα χρησιμοποιήσουμε τη συνάρτηση `is_even/1` από την ενότητα Integer για να ελέγξουμε αν μια τιμή είναι ζυγή ή όχι.


```elixir
 for x <- 1..10, is_even(x), do: x
```

Όπως τους παραγωγούς, μπορούμε να χρησιμοποιήσουμε πολλαπλά φίλτρα.  Ας επεκτείνουμε το εύρος και να φιλτράρουμε μόνο τις τιμές που είναι ζυγές και διαρέσιμες με το 3.


```elixir
 for x <- 1..100,
```

## Χρησιμοποίηση της :into

Τι γίνεται αν θέλουμε να παράγουμε κάτι άλλο πέρα από λίστα;  Μπορούμε να το κάνουμε χρησιμοποιώντας την `:into`! Σε γενικές γραμμές η `:into` δέχεται κάθε δομή που υλοποιεί το πρωτόκολο `Collectable`.

Χρησιμοποιώντας την `:into`, ας δημιουργήσουμε ένα χάρτη από μια λίστα λέξεων κλειδί:


```elixir
 for {k, v} <- [one: 1, two: 2, three: 3], into: %{}, do: {k, v}
```

Από τη στιγμή που τα αλφαριθμητικά είναι συλλογές μπορούμε να χρησιμοποιήσουμε την ανάγνωση λιστών και την `:into` για να δημιουργήσουμε αλφαριθμητικά:


```elixir
 for c <- [72, 101, 108, 108, 111], into: "", do: <<c>>
```

Αυτό ήταν!  Οι αναγνώσεις λιστών είναι ένας έυκολος τρόπος να προσπελάσουμε συλλογές με συνοπτικό τρόπο.
