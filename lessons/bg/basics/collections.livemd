# Колекции

## Списъци

Списъците са прости колекции от стойности, могат да се състоят от множество типове; списъците може да съдържат еднакви стойности:


```elixir
 [3.14, :pie, "Apple"]
```

Elixir имплементира списъка като свързан списък.  Това означава, че дължината на списъка е операция от реда `O(n)`.  Поради тази причина по-принцип е по-бързо да се добавя в началото отколкото в края на списък:


```elixir
 list = [3.14, :pie, "Apple"]
```

```elixir
 ["π" | list]
```

```elixir
 list ++ ["Cherry"]
```


### Конкатенация на списъци

За конкатенацията на списъци се използва оператора `++/2`:


```elixir
 [1, 2] ++ [3, 4, 1]
```

Бележка относно формата името (`++/2`) използван отгоре: В Elixir(и Erlang върху, който Elixir е създаден), името на функция или оператор има два компонента: даденото й име(в този случай `++`) и нейното _arity_. Arity е основна част, когато се говори за Elixir (и Erlang) код. Това е броя на аргументите, дадена функция приема(в този случай две). Arity и името са комбинирани с наклонена черта. Ще говорим за това повече по-късно; Това ще ви помогне да разберете нотацията за сега.


### Разлика на списъци

Поддръжката за изважадне е осигурено чрез оператора `--/2`; безопасно е да се извади липсваща стойност:


```elixir
 ["foo", :bar, 42] -- [42, "bar"]
```

Внимавайте с повтарящи се стойности. Първата поява на всеки елемент от дясно, се премахва от ляво:


```elixir
 [1,2,2,3,2,3] -- [1,2,3,2]
```

**Забележка:** Използва се [стриктно сравнение](/bg/lessons/basics/basics#comparison) при сравнението на стойности.

### Глава / Опашка

Когато използваме списъци е обичайно да работим с главата и опашката на списъка. Главата е първият елемент на списъка, а опашката — останалите елементи.  Elixir предоставя два полезни метода, `hd` и `tl`, за работа с тези части:


```elixir
 hd [3.14, :pie, "Apple"]
```

```elixir
 tl [3.14, :pie, "Apple"]
```

В допълнение към гореспоменатите функции, може да ползвате [pattern matching](/bg/lessons/basics/pattern_matching) и оператора `|` за да разделите списъка на глава и опашка; ще разгледаме този подход в дълбочина в следващи уроци:


```elixir
 [head | tail] = [3.14, :pie, "Apple"]
```

```elixir
 head
```

```elixir
 tail
```


## Tuples

Tuples са подобни на списъци, но се съхраняват последователно в паметта.  Поради това достъпваме тяхната дължина бързо, но модификациите са скъпи; новият tuple трябва да бъде изцяло копиран наново в паметта.  Tuples се дефинират с къдрави скоби:


```elixir
 {3.14, :pie, "Apple"}
```

Обичайно за tuples е да бъдат използвани като механизъм за връщане на допълнителна информация от функции; полезността от това ще стане по-ясна след като навлезем в pattern matching:


```elixir
 File.read("path/to/existing/file")
```

```elixir
 File.read("path/to/unknown/file")
```

## Списъци с ключови думи

Ключовите думи и асоциативните списъци са асоциативните колекции на Elixir.  В Elixir, списък от ключови думи е специален списък от tuples, чиито първи елемент е атом; те имат производителността на списък:


```elixir
 [foo: "bar", hello: "world"]
```

```elixir
 [{:foo, "bar"}, {:hello, "world"}]
```

Трите характеристики на списъци с ключови думи подчертават тяхната важност:

+ Ключовете са атоми.
+ Ключовете са подредени.
+ Ключовете не са уникални.

Поради тези причини списъците с ключови думи най-често се ползват за предаване на опции към функции.

## Асоциативни списъци

В Elixir асоциативните списъци съхраняват стойности тип ключ-стойност, за разлика от списъците с ключови думи, те позволяват ключове от всякакъв тип и не са подредени.  Може да дефинирате асоциативен списък с`%{}`:


```elixir
 map = %{:foo => "bar", "hello" => :world}
```

```elixir
 map[:foo]
```

```elixir
 map["hello"]
```

Считано от Elixir 1.2, може да използвате променливи като ключове в асоциативния списък:


```elixir
 key = "hello"
```

```elixir
 %{key => "world"}
```

Ако дубликат е добавен към асоциативен списък, той ще замени предходната стойност:


```elixir
 %{:foo => "bar", :foo => "hello world"}
```

Както може да видим от резултата по-горе, съществува специален синтаксис за асоциативни списъци, които съдържат само атоми като ключове:


```elixir
 %{foo: "bar", hello: "world"}
```

```elixir
 %{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}
```

Когато ключовете са от тип атом, те са достъпни чрез специалиен синтаксис:

```elixir
 map = %{foo: "bar", hello: "world"}
```

```elixir
 map.hello
```

Друго интересно свойство на асоциативните списъци е техния синтаксис за обновяване:


```elixir
 map = %{foo: "bar", hello: "world"}
```

```elixir
 %{map | foo: "baz"}
```
