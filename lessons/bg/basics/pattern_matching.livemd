# Съпоставка с образец

## Оператор за съпоставка

Готови ли сте за ниска топка?  При Elixir, операторът `=` е всъщност нашият оператор за съпоставяне.  Чрез оператора за съпоставка можем да присвояваме и след това съпоставяме стойности, нека видим:


```elixir
 x = 1
```

А сега нека пробваме някои прости съпоставки с образец:


```elixir
 1 = x
```

```elixir
 2 = x
```

Нека опитаме същото с някои от познатите ни колекции:


```elixir
 list = [1, 2, 3]
```

```elixir
 [1, 2, 3] = list
```

```elixir
 [] = list
```

```elixir
 [1 | tail] = list
```

```elixir
 tail
```

```elixir
 [2|_] = list
```

```elixir
 {:ok, value} = {:ok, "Successful!"}
```

```elixir
 value
```

```elixir
 {:ok, value} = {:error}
```

## Оператор за забождане

Тъкмо научихме, че оператора за съпоставяне изпълнява присвояването когато лявата страна на съпоставката съдържа променлива.  В някой случаи това поведение, повторно присвояване на променлива, е нежелателно.  За такива случаи имаме оператора за 'забождане': `^`.

Когато забодем променлива, ние съпоставяме върху съществуващата стойност, а не присвояваме нова такава към променливата.  Нека видим как действа това:


```elixir
 x = 1
```

```elixir
 ^x = 2
```

```elixir
 {x, ^x} = {2, 1}
```

```elixir
 x
```

Elixir 1.2 добави поддръжка за забождане в ключове на асоциативни листи и клаузи на функции:


```elixir
 key = "hello"
```

```elixir
 %{^key => value} = %{"hello" => "world"}
```

```elixir
 value
```

```elixir
 %{^key => value} = %{:hello => "world"}
```

Пример за забождане в клауза на функция:


```elixir
 greeting = "Hello"
```

```elixir
 greet = fn
```

```elixir
 greet.("Hello", "Sean")
```

```elixir
 greet.("Mornin'", "Sean")
```
