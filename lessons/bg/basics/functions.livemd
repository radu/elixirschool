# Функции

## Анонимни функции

Както името подсказва, анонимната функция няма име.  Както видяхме в урока относно `Enum`, те често се подават към други функции.  За да дефинираме анонимна функция в Elixir се нуждаем от ключовите думи `fn` и `end`.  Между тях може да дефинираме всякакъв брой параметри и имплементации на функции, разграничени от `->`.

Нека погледнем един прост пример:


```elixir
 sum = fn (a, b) -> a + b end
```

```elixir
 sum.(2, 3)
```

### Съкращението &

Да се използват анонимни функции е толкова често срещано в  Elixir, че за употребата им има съкращение:


```elixir
 sum = &(&1 + &2)
```

```elixir
 sum.(2, 3)
```

Както сигурно сте се досетили, в съкратената версия параметрите ни са достъпни за нас като `&1`, `&2`, `&3`, и т.н.

## Съпоставка с образец

Съпоставката с образец не е ограничена само до променливи в Elixir, може да се приложи и върху функции, както ще видим в тази секция.

Elixir използва съпоставката с образец, за да идентифицира първия подходящ набор от параметри и извиква съответната имплементация:


```elixir
 handle_result = fn
```

```elixir
 some_result = 1
```

```elixir
 handle_result.({:ok, some_result})
```

```elixir
 handle_result.({:error})
```

## Именовани функции

Можем да дефинираме функции с имена, за да ги достъпваме на по-късен етап, тези наименовани функции се дефинират с ключовата дума `def` в модул.  Ще научим повече за модулите в следващите уроци, засега ще се фокусираме само върху именовани функции.

Функции дефинирани в модул са достъпни и от други модули, това е изключително полезна конструкция в Elixir:


```elixir
 Greeter.hello("Sean")
```

Ако нашата имплементация на функция е само един ред, може да я скъсим допълнително с `do:`:


```elixir
defmodule Greeter do
  def hello(name), do: "Hello, " <> name
end
```

Въоръжени със знанието за съпоставка с образец, нека разгледаме рекурсия използвайки именовани функции:


```elixir
 Length.of []
```

```elixir
 Length.of [1, 2, 3]
```

### Именоване на фукнции и Arity

Споменахме по-рано, че функциите се именоват с комбинация от дадено име и arity(броя аргументи). Това означава, че може да се правят неща като:


```elixir
 Greeter2.hello()
```

```elixir
 Greeter2.hello("Fred")
```

```elixir
 Greeter2.hello("Fred", "Jane")
```

Изредили сме имената на функциите в коментарите отгоре. Първата имплементация приема нула аргумента, за това е `hello/0`; втората приема един аргумент и е `hello/1`, и т.н. За разлика от предефинирани функции в някои други езици, за тези се мисли като __отделни__ една от друга. (Съпоставката с образец, описан преди момент, се отнася само когато няколко дефиниции са осигурени за дефиниции на функции със __същия__ брой аргументи.)

### Частни функции

Когато не желаем други модули да достъпват дадена функция може да ползваме частни функции, които могат да бъдат достъпвани само от техния модул.  Можем да ги дефинираме в Elixir посредством `defp`:


```elixir
 Greeter.hello("Sean")
```

```elixir
 Greeter.phrase
```

### Ограничители

Бегло споменахме ограничители в урока [Контролни структури](/bg/lessons/basics/control_structures), сега ще видим как да ги приложим към именовани функции.  Веднъж като Elixir е намерил подходяща функция всички съществуващи ограничители ще бъдат тествани.

В следващия пример имаме две еднакво разписани функции, разчитаме на ограничители, за да разберем коя да бъде използвана базирано на типа на аргумента:


```elixir
 Greeter.hello ["Sean", "Steve"]
```

### Аргументи по подразбиране

Ако искаме да имаме стойност по подразбиране за аргумент използваме синтаксиса `аргумент \\ стойност`:


```elixir
 Greeter.hello("Sean", "en")
```

```elixir
 Greeter.hello("Sean")
```

```elixir
 Greeter.hello("Sean", "es")
```

Когато комбинираме примера ни с ограничители със стойности по подразбиране, се сблъскваме с проблем.  Нека видим как изглежда:


```elixir
defmodule Greeter do
  def hello(names, language_code \\ "en") when is_list(names) do
    names = Enum.join(names, ", ")

    hello(names, language_code)
  end

  def hello(name, language_code \\ "en") when is_binary(name) do
    phrase(language_code) <> name
  end

  defp phrase("en"), do: "Hello, "
  defp phrase("es"), do: "Hola, "
end

** (CompileError) iex:31: definitions with multiple clauses and default values require a header. Instead of:

    def foo(:first_clause, b \\ :default) do ... end
    def foo(:second_clause, b) do ... end

one should write:

    def foo(a, b \\ :default)
    def foo(:first_clause, b) do ... end
    def foo(:second_clause, b) do ... end

def hello/2 has multiple clauses and defines defaults in one or more clauses
    iex:31: (module)
```

Elixir не харесва аргументи със стойност по подразбиране при наличие на няколко подходящи функции, това води до объркване.  За да се справим с това добавяме описателна функция с нашите стойности по подразбиране:


```elixir
 Greeter.hello ["Sean", "Steve"]
```

```elixir
 Greeter.hello ["Sean", "Steve"], "es"
```
