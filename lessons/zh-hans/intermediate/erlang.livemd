# 和 Erlang 互操作

## 标准库

在任何 Elixir 代码中都能直接使用 Erlang 提供的标准库，Erlang 的模块用小写的原子变量表示，比如 `:os` 和 `:timer`。  

我们可以用 `timer.tc` 计算某个函数执行的时间：  


```elixir
 Example.timed(fn (n) -> (n * n) * n end, [100])
```

要了解所有可用的模块，请看 [Erlang 参考手册](http://erlang.org/doc/apps/stdlib/)。  

## Erlang 第三方依赖

在之前的课程中，我们讲过如何使用 Mix 和管理依赖。要引入 Erlang 的依赖，方法也是一样的。如果依赖的 Erlang 库不在 [hex](https://hex.pm)，你也可以直接使用 git 代码库的地址：  


```elixir
def deps do
  [{:png, github: "yuce/png"}]
end
```

然后我们就可以用 Erlang 的库了：  


```elixir
png =
  :png.create(%{:size => {30, 30}, :mode => {:indexed, 8}, :file => file, :palette => palette})
```

## 区别

知道了怎么在 Elixir 中使用 Erlang ，我们还要讲讲操作 Erlang 语言会遇到的坑：  

### 原子

Erlang 的原子和 Elixir 很相似，只是没有前面的冒号（`:`），Erlang 中的原子是小写字母和下划线的组合。  

Elixir:  


```elixir
:example
```

Erlang:  

```erlang
example.
```

### 字符串

在 Elixir 里面，字符串表达的是 UTF-8 编码的二进制数据。而在 Erlang，字符串还是使用双引号表示，但是却是字符列表。  

Elixir:  


```elixir
 is_list('Example')
```

```elixir
 is_list("Example")
```

```elixir
 is_binary("Example")
```

```elixir
 <<"Example">> === "Example"
```

Erlang:  

```erlang
1> is_list('Example').
false
2> is_list("Example").
true
3> is_binary("Example").
false
4> is_binary(<<"Example">>).
true
```

需要特别注意的是，有些 Erlang 的库不支持二进制数据，我们要把 Elixir 字符串转换成字符列表。还好，`to_charlist/1` 函数可以帮我们轻松完成这个转换。  


```elixir
 :string.words("Hello World")
```

```elixir
 "Hello World" |> to_charlist() |> :string.words()
```

### 变量

在 Erlang 中，变量是以大写的字符开头，并且不允许重新绑定

Elixir:  


```elixir
 x = 10
```

```elixir
 x = 20
```

```elixir
 x1 = x + 10
```

Erlang:  

```erlang
1> X = 10.
10

2> X = 20.
** exception error: no match of right hand side value 20

3> X1 = X + 10
20
```

就这么多！在 Elixir 应用中使用 Erlang 简单高效，把原来可用的库直接加倍啦！  
