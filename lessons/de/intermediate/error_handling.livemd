# Fehlerbehandlung

## Fehlerbehandlung

Bevor wir Fehler behandeln können, müssen wir sie erzeugen und der einfachste Weg dies zu tun ist mit `raise/1`:


```elixir
 raise "Oh no!"
```

Falls wir den Typ und eine Nachricht angeben wollen, müssen wir `raise/2` benutzen:


```elixir
 raise ArgumentError, message: "the argument value is invalid"
```

Wenn wir wissen, dass ein Fehler auftreten kann, können wir diesen mit `try/rescue` und pattern matching behandeln:


```elixir
 try do
```

Es ist möglich mehrere Fehler in einem einzelnen rescue zu behandeln:


```elixir
try do
  opts
  |> Keyword.fetch!(:source_file)
  |> File.read!
rescue
  e in KeyError -> IO.puts "missing :source_file option"
  e in File.Error -> IO.puts "unable to read source file"
end
```

## After

Manchmal kann es notwendig sein, eine bestimmte Aktion nach unserem `try/rescue` auszuführen, unabhängig vom Fehler. Dafür haben wir `try/after`.  Falls du mit Ruby vertraut bist, ist dir das als `begin/rescue/ensure` bekannt oder aus Javas `try/catch/finally`:


```elixir
 try do
```

Das wird meistens mit Dateien oder Verbindungen eingesetzt, welche geschlossen werden müssen:


```elixir
{:ok, file} = File.open "example.json"
try do
   # Tue etwas gefährliches
after
   File.close(file)
end
```

## Neue Fehler

Während Elixir bereits eine große Zahl an eingebauten Fehlertypen wie `RuntimeError` bietet, haben wir dennoch die Möglichkeit unsere eigenen zu erstellen, falls wir etwas spezielles brauchen. Einen neuen Fehler zu erstellen ist einfach mit dem `defexception/1`-Makro, welches praktischerweise eine `:message`-Option bietet, um die Standardnachricht festzulegen:


```elixir
defmodule ExampleError do
  defexception message: "an example error has occurred"
end
```

Lass uns unseren neuen Fehler ausprobieren:


```elixir
 try do
```

## Throws

Ein weiterer Mechanismus, um mit Fehlern in Elixir zu arbeiten, ist `throw` und `catch`. In der Praxis treten diese selten in neuerem Elixir Code auf, aber es ist dennoch wichtig sie zu kennen und zu verstehen.

Die `throw/1`-Funktion erlaubt uns die Ausführung mit einem bestimmten Wert zu verlassen, den wir mit `catch` auffangen und weiter benutzen können:


```elixir
 try do
```

Wie bereits erwähnt wurde, ist `throw/catch` ziemlich selten und existiert als Lückenbüßer, wenn Bibliotheken keine passende bessere API bieten.

## Exit

Der letzte Fehler-Mechanismus in Elixir ist `exit`. Exit-Signale treten in Elixir auf, wenn ein Prozess stirbt und ist ein wichtiger Teil der Fehlertoleranz in Elixir.

Um explizit auszusteigen, können wir `exit/1` benutzen:


```elixir
 spawn_link fn -> exit("oh no") end
```

Während es möglich ist einen Austieg durch `try/catch` zu behandeln, ist es _extrem_ selten dies zu tun. In fast allen Fällen ist es besser den supervisor den Prozess-exit handhaben zu lassen:


```elixir
 try do
```
