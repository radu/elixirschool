# Nebenläufigkeit

## Prozesse

Prozesse in der Erlang VM sind leichtgewichtig und laufen verteilt auf allen CPUs. Während sie wie native Threads wirken sind sie simpler und es ist nicht ungewöhnlich mehrere Tausend nebenläufige Prozesse in einer Elixiranwendung zu haben.

Der einfachste Weg einen Prozess zu erzeugen ist durch `spawn`, welche eine anonyme oder benannte Funktion entgegen nimmt. Wenn wir einen neuen Prozess erzeugen gibt uns dieser einen _Process Identifier_, auch PID genannt, zurück, welcher den Prozess in unserer Anwendung eindeutig identifiziert.

Für den Start schreiben wir ein Modul und definieren eine Funktion, die wir gerne laufen lassen würden:


```elixir
 Example.add(2, 3)
```

Um die Funktion asynchron auszuwerten benutzen wir `spawn/3`:


```elixir
 spawn(Example, :add, [2, 3])
```

### Message Passing

Zur Kommunikation benutzen Prozesse message passing. Zwei Komponenten werden hierfür benötigt: `send/2` und `receive`. Die Funktion `send/2` erlaubt uns Nachrichten an PIDs zu schicken. Auf der anderen Seite nutzen wir `receive` um Nachrichten zu empfangen. Falls keine Übereinstimmung gefunden wird läuft die Ausführung ohne Unterbrechung weiter.


```elixir
 pid = spawn(Example, :listen, [])
```

```elixir
 send pid, {:ok, "hello"}
```

```elixir
 send pid, :ok
```

Bei genauer Betrachtung des Codes fällt auf, dass die `listen/0` Funktion rekursiv ist, was unserem Prozess erlaubt mehrere Nachrichten zu empfangen. Ohne Rekursion würde unser Prozess einfach beendet werden, nachdem die erste Nachricht ausgewertet wurde.

### Kopplung von Prozessen

Ein Problem mit `spawn` ist mitzubekommen, wenn ein Prozess abgestürzt ist. Dafür müssen wir unsere Prozesse mit `spawn_link` verbinden. Zwei auf diese Art verbundene Prozesse bekommen mit, sollte der andere abstürzen:


```elixir
 spawn(Example, :explode, [])
```

```elixir
 spawn_link(Example, :explode, [])
```

Manchmal wollen wir nicht, dass ein abgestürzter Prozess den aktuelle Prozess zum abstürzen bringt. Dafür müssen wir die exits abfangen. Beim Abfangen von exits werden sie als Nachrichtentupel empfangen: `{:EXIT, from_pid, reason}`.


```elixir
 Example.run
```

### Monitoring von Prozessen

Was wenn wir zwei Prozesse nicht verbinden wollen, aber dennoch informiert werden? Dafür können wir Prozesse mit `spawn_monitor` überwachen. Wenn wir einen Prozess überwachen bekommen wir eine Nachricht falls der Prozess abstürzt, ohne dass unser aktueller Prozess mitabstürzt. Ebensowenig müssen wir dazu exits abfangen.


```elixir
 Example.run
```

## Agenten

Agenten sind eine Abstraktion über Hintergrundprozesse welche einen Zustand beibehalten. Wir können sie von anderen Prozessen innerhalb unserer Anwendung und aller Knoten abrufen. Der Zustand unserer Agenten wird auf den Rückgabewert unserer Funktion gesetzt:


```elixir
 {:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
```

```elixir
 Agent.update(agent, fn (state) -> state ++ [4, 5] end)
```

```elixir
 Agent.get(agent, &(&1))
```

Durch Benennung eines Agenten können wir diesen direkt ansprechen, anstatt auf dessen PID zurückgreifen zu müssen:


```elixir
 Agent.start_link(fn -> [1, 2, 3] end, name: Numbers)
```

```elixir
 Agent.get(Numbers, &(&1))
```

## Tasks

Tasks erlauben eine Funktion im Hintergrund auszuführen und deren Rückgabewert später zu erhalten. Sie sind besonders nützlich wenn aufwendige Berechnungen durchgeführt werden, ohne die Ausführung der Anwendung zu blockieren.


```elixir
 task = Task.async(Example, :double, [2000])
```

```elixir
 Task.await(task)
```
