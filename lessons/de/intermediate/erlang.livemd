# Erlang-Interoperabilität

## Standardbibliothek

Erlangs rießige Standardbibliothek kann direkt von Elixir Code in unserer Anwendung benutzt werden. Erlang-Module werden durch atoms in Kleinbuchstaben dargestellt wie etwa `:os` oder `:timer`.

Lass uns `:timer.tc` benutzen, um die Ausführungszeit einer gegebenen Funktion zu messen:


```elixir
 Example.timed(fn (n) -> (n * n) * n end, [100])
```

Für eine vollständige Liste an verfügbaren Modulen siehe [Erlang Reference Manual](http://erlang.org/doc/apps/stdlib/).

## Erlang-Pakete

In der vorigen Lektion haben wir Mix und die Verwaltung von Abhängigkeiten besprochen. Erlang-Bibliotheken zu benutzen funktioniert auf die gleiche Weise. Für den Fall, dass die Erlang-Bibliothek nicht auf [Hex](https://hex.pm) veröffentlicht wurde, kannst du direkt auf das git-Repository zurückgreifen:


```elixir
def deps do
  [{:png, github: "yuce/png"}]
end
```

Jetzt können wir unsere Erlang-Bibliothek nutzen:


```elixir
png =
  :png.create(%{:size => {30, 30}, :mode => {:indexed, 8}, :file => file, :palette => palette})
```

## Auffallende Unterschiede

Jetzt da wir wissen, wie man Erlang einbindet, lass uns einige häufig gemachte Fehler anschauen, die in Bezug mit Erlang-Interoperabilität öfters auftreten.

### Atoms

Erlang atoms ähneln denen Elixirs ohne den Doppelpunkt (`:`). Sie werden mit kleingeschriebenen Strings und Unterstrichen dargestellt:

Elixir:


```elixir
:example
```

Erlang:

```erlang
example.
```

### Strings

In Elixir meinen wir UTF-8 codierte binaries, wenn wir von Strings reden. In Erlang werden Strings auch durch doppelte Anführungszeichen gekennzeichnet, sind jedoch char lists:

Elixir:


```elixir
 is_list('Example')
```

```elixir
 is_list("Example")
```

```elixir
 is_binary("Example")
```

```elixir
 <<"Example">> === "Example"
```

Erlang:

```erlang
1> is_list('Example').
false
2> is_list("Example").
true
3> is_binary("Example").
false
4> is_binary(<<"Example">>).
true
```

Es ist wichtig sich zu merken, dass viele ältere Erlang-Bibliotheken keine binaries unterstützen und wir somit Elixir strings in char lists umwandeln müssen. Glücklicherweise ist das mit der `to_charlist/1`-Funktion kein Problem:


```elixir
 :string.words("Hello World")
```

```elixir
 "Hello World" |> to_charlist |> :string.words
```

### Variablen

Elixir:


```elixir
 x = 10
```

```elixir
 x1 = x + 10
```

Erlang:

```erlang
1> X = 10.
10

2> X1 = X + 1.
11
```

Das war's! Erlang von unseren Elixir-Anwendungen zu benutzen ist einfach und verdoppelt effektiv die Anzahl an verfügbaren Bibiliotheken.
