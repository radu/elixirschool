# Grundlagen

## Grundlagen

### Elixir installieren

Installationsanleitungen für jedes Betriebssystem können auf elixir-lang.org unter [Installing Elixir](http://elixir-lang.org/install.html) gefunden werden.

Nachdem Elixir installiert ist, kann die installierte Version einfach überprüft werden.

    % elixir -v
    Erlang/OTP {{ site.erlang.OTP }} [erts-{{ site.erlang.erts }}] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

    Elixir {{ site.elixir.version }}

### Benutzen des interaktiven Modus

Elixir kommt mit `iex`, einer interaktiven Shell, welche uns erlaubt Ausdrücke in Elixir auszuwerten.

Zum Loslegen starten wir `iex`:

    Erlang/OTP {{ site.erlang.OTP }} [erts-{{ site.erlang.erts }}] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

    Interactive Elixir ({{ site.elixir.version }}) - press Ctrl+C to exit (type h() ENTER for help)
    iex>

Lass uns fortfahren und ein paar einfache Audrücke ausprobieren:


```elixir
 2+3
```

```elixir
 2+3 == 5
```

```elixir
 String.length("Franz jagt im komplett verwahrlosten Taxi quer durch Bayern")
```

Falls du momentan noch nicht jeden Ausdruck versteht, mach dir darüber keine Gedanken. Wir denken du wirst dir bald ein Bild davon machen können.

## Einfache Datentypen

### Integer


```elixir
 255
```

Unterstützung für Binär-, Oktal- und Hexadezimalzahlen wird mitgeliefert:


```elixir
 0b0110
```

```elixir
 0o644
```

```elixir
 0x1F
```

### Gleitkommazahlen

In Elixir verlangen Gleitkommazahlen mindestens einen Punkt nach einer Zahl; sie haben 64 Bit double precision und überstützen `e` für Exponenten:


```elixir
 3.14
```

```elixir
 .14
```

```elixir
 1.0e-10
```


### Booleans

Elixir unterstützt `true` und `false` als Booleans; alles außer `false` und `nil` wird als wahr betrachtet:


```elixir
 true
```

```elixir
 false
```

### Atoms

Ein Atom ist eine Konstante, bei der der Name auch den Wert darstellt. Falls du mit Ruby vertraut bist kennst du Atoms als Symbole:


```elixir
 :foo
```

```elixir
 :foo == :bar
```

Booleans `true` und `false` sind gleichwertig zu den Atoms `:true` und `:false`.


```elixir
 is_atom(true)
```

```elixir
 is_boolean(:true)
```

```elixir
 :true === true
```

Modulnamen in Elixir sind auch Atoms. `MyApp.MyModule` ist ein gültiges Atom, auch wenn dieses Modul noch nicht deklariert wurde.


```elixir
 is_atom(MyApp.MyModule)
```

Atoms werden auch dazu genutzt, um Module aus Erlangbibiliotheken zu referenzieren. Dies gilt auch für in Erlang bereits vorhandenen Bibiliotheken.


```elixir
 :crypto.strong_rand_bytes 3
```

### Strings

Strings in Elixir sind UTF-8 codiert und in doppelten Anführungszeichen zu schreiben:


```elixir
 "Hello"
```

```elixir
 "dziękuję"
```

Strings unterstützen Zeilenumbrüche und Escapesequenzen:


```elixir
 "foo
```

```elixir
 "foo\nbar"
```

Elixir unterstützt auch komplexere Datentypen. Wir werden mehr darüber erfahren wenn wir Collections und Funktionen lernen.

## Einfache Operationen

### Arithmetik

Elixir unterstützt die grundlegenden Operatoren `+`, `-`, `*`, und `/`. Wichtig dabei ist zu beachten, dass `/` immer Float zurück gibt:


```elixir
 2 + 2
```

```elixir
 2 - 1
```

```elixir
 2 * 5
```

```elixir
 10 / 5
```

Falls du Integerdivision oder den Rest der Division brauchst hat Elixir zwei hilfreiche Funktionen dafür:


```elixir
 div(10, 5)
```

```elixir
 rem(10, 3)
```

### Boolean

Elixir bringt `||`, `&&` und `!` an Booleschen Operatoren mit. Diese unterstützen jeden Typ:


```elixir
 -20 || true
```

```elixir
 false || 42
```

```elixir
 42 && true
```

```elixir
 42 && nil
```

```elixir
 !42
```

```elixir
 !false
```

Es gibt drei weitere Operatoren, deren erstes Argument ein Boolean sein _muss_:


```elixir
 true and 42
```

```elixir
 false or true
```

```elixir
 not false
```

```elixir
 42 and true
```

```elixir
 not 42
```

### Vergleiche

Elixir kommt mit diversen vergleichenden Operatoren: `==`, `!=`, `===`, `!==`, `<=`, `>=`, `<` und `>`.


```elixir
 1 > 2
```

```elixir
 1 != 2
```

```elixir
 2 == 2
```

```elixir
 2 <= 3
```

Für strikte Vergleiche von Integern und Floats benutze `===`:


```elixir
 2 == 2.0
```

```elixir
 2 === 2.0
```

Ein wichtiges Feature von Elixir ist, dass jegliche zwei Typen miteinander verglichen werden können. Das ist beispielsweise dann praktisch, wenn man die Typen sortieren möchte. Wir müssen uns nicht an die Sortierreihenfolge erinnern, aber es ist wichtig zu wissen, dass es sie gibt:


```elixir
number < atom < reference < function < port < pid < tuple < map < list < bitstring
```

Das führt mitunter zu interessanten, aber gültigen, Vergleichen, welche es so in anderen Sprachen nicht gibt:


```elixir
 :hello > 999
```

```elixir
 {:hello, :world} > [1, 2, 3]
```

### String Interpolation

Falls du Ruby kennst wird dir String Interpolation in Elixir bekannt vorkommen:


```elixir
 name = "Sean"
```

```elixir
 "Hello #{name}"
```

### String-Verkettung

String-Verkettung benutzt den `<>` Operator:


```elixir
 name = "Sean"
```

```elixir
 "Hello " <> name
```
